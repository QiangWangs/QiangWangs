关系型数据库：
1.基于行存储数据
2.结构化 schema
3.关联 relationship
4.SQL
5.支持事务ACID

非关系型数据库：
1.非结构化的数据
2.表之间没有关联
3.最终一致性 BASE

SQL执行流程
客户端 --连接-> 查询缓存 -> 解析器 -> 预处理器 -> 查询优化器 -> 执行计划 -> 执行引擎 -> 存储引擎

1.连接层(管理连接，权限验证)
2.服务层:
解析器 -> 缓存(词法解析, 语法解析)
优化器(执行计划生成, 索引选择)
执行器(操作引擎-管理数据，返回结果)
3.存储引擎层(存储数据,提供读写接口)

连接:
通信方式: 同步/异步
连接方式：长连接/短连接

缓存模块：Query Cache   (从 MySQL 8.0 开始，查询缓存功能已被移除。 缓存很鸡肋,因为表数据变化频繁,缓存命中率低)

解析器(Parser):
词法解析: 把一个完整的Sql语句分解成一个个的单词
语法解析: 语法检查

解析数:
select Fields(字段) from Tables(表名) where Conditions(条件)

预处理器 Preprocessor
语义解析: 表名、字段名解析，别名解析，表达式和函数的解析，类型检查
权限处理: 权限检查

优化器(Optimizer)
执行计划 Execution Plan 基于成本(cost)
show variables like 'optimizer_trace';  -- 查看是否开启optimizer_trace,开启后可以查看更详细的执行计划
set optimizer_trace="enabled=on";  -- 开启optimizer_trace  #enabled=off,one_line=off
--
select * from information_schema.optimizer_trace;  -- 查看执行计划

执行器
使用执行计划调用存储引擎API获取数据





-- log_bin 是 ON,就说明打开了， OFF就是关闭的
show variables like 'log_bin';
-- 找到binlog文件名
show master logs;
show binary logs;
-- 查看binlog日志位置
show variables like '%datadir%';
-- 查看日志文件信息
show binlog events in 'binlog.000059';
-- mysqlbinlog --start-position=2038 --stop-position=1025477521 /var/lib/mysql/binlog.000059 | mysql -uroot -p ;




 预读取: 16kb
 innoDB 内存缓存区 buffer pool


MySql事务


索引
索引是数据库非常重要的数据结构,他可以看做是数据库的目录,针对数据库中单列或者多列的值按照某种规则（如B树、哈希表等）进行排序的一种结构,
能比数据库全表扫描更快的方式查找,定位,访问数据库中的数据.可以显著的提供数据检索的速度。
使用索引能减少磁盘I/O次数和数据库扫描次数，提高性能。
通过explain关键字来分析，key有值走索引，否则就没走索引。

索引类型
1、普通索引，基本的索引，没有任何限制，用于加速查询，数据可以重复CREATE INDEX indexName（索引名） ON mytable（表名）(username字段名(length长度一般全文索引使用));
2、组合索引，指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用
CREATE INDEX index_name ON table_name (column1, column2, ...);
3、全文索引，用来查找文本中的关键字
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)
4、唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。
CREATE UNIQUE INDEX indexName ON mytable(username(length))或者ALTER table mytable ADD UNIQUE indexName (username(length))
5、主键索引，特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。也就是在唯一索引的基础上相应的列必须为主键
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)
6、聚集索引：有时也称为主键索引（但二者又不能等同）在聚集索引里，表中数据行按索引的排序方式进行存储，对查找行很有效。只有当表包含聚集索引时，表内的数据行才会按找索引列的值在磁盘上进行物理排序和存储。每张表只能有一个聚集索引，原因很简单，因为数据行本身只能按一个顺序存储。
7、非聚集索引：非聚集索引也称为二级索引或者辅助索引，对于非聚集索引，数据库会有单独的存储空间来存放。非聚集索引在查找的时候要经过两个步骤，需要先搜索非聚集索引的B+Tree，这个B+Tree的叶子结点存储的不是完整的数据行，而是主键值，当我们搜索完成后得到主键的值，然后拿着主键值再去搜索主键索引的B+Tree，就可以获取到一行完整的数据。一系列的普通索引都可以归纳到非聚集索引，如：普通索引、唯一索引、全文索引；

索引的优点缺点
索引的原理大致概括为以空间换时间
数据库中索引的作用是提高查询效率，它可以使得查询数据的速度更快。
优点：
1、通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
2、可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
3、可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
4、在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
5、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
提高查询速度：
索引可以显著提高数据检索的速度，因为它允许数据库系统以比全表扫描更快的方式定位数据。
排序和范围查询：
B+树索引支持排序和范围查询操作，使得这些操作更加高效。
提高数据操作的效率：
索引不仅可以用于查询操作，还可以用于数据的插入、更新和删除操作（尽管在某些情况下可能会增加这些操作的开销）。
缺点：
1、创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
2、索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间
就会更大。
3、当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
占用物理空间：
索引需要占用额外的物理空间来存储索引数据和索引结构。
维护成本：
当表中的数据发生变化时（如插入、更新、删除操作），索引也需要进行相应的维护操作（如重建、调整等），这会增加额外的开销。
可能降低写操作的性能：
在某些情况下，索引可能会降低写操作的性能（如插入、更新、删除操作的速度可能会变慢）。




索引：
数据库索引，是数据库管理系统(DBMS) 中一个排序的数据结构，以协调快速查询,更新数据库表中数据
索引类型与方法
Normal , Unique , Fulltext

创建索引
1、在用于where判断order排序和join的（on）字段上创建索引。
2、索引的个数不要过多。
3、区分度低的字段，例如性别，不要建索引。
4、频繁更新的值，不要作为主键或者索引。
5、符合索引把散列性高（区分度高）的值放在前面。
6、创建复合索引，而不是修改单列索引。
7、过长的字段，怎么建立索引？
8、为什么不建议用无序的值（例如身份证、UUID ）作为索引？
离散度

B+Tree 的特点
 B Tree能解决的问题，B+Tree都能解决
 扫库、扫表能力更强
 磁盘读写能力更强
 排序能力更强
 效率更加稳定

MySQL优化、覆盖索引 、回表 、索引下推
覆盖索引:
explain的输出结果Extra字段为Using index时，能够触发索引覆盖。
将被查询的字段，建立到联合索引里去。
命中索引，索引叶子节点存储了主键id，通过索引树即可获取，无需回表，符合索引覆盖，效率较高。
不符合索引覆盖，需要再次通过id值扫描聚集索引获取字段，效率会降低。 解决由单列索引升级为联合索引
  利用覆盖所以加最左原则，减少对索引的维护,因为是覆盖，所以可以避免排序用到的临时文件。

回表查询:
先定位主键值，再定位行记录，它的性能较扫一遍索引树更低
聚集索引（主键或第一个唯一索引）就不会回表，普通索引就会回表。

索引下推:（Index condition pushdown）简称ICP
是一种优化数据库查询的技术，它利用了数据库索引的特性，在一定条件下，在索引层面就过滤掉不需要的数据，从而减少查询时需要访问的数据块，提高查询效率。
优点是减少了回表操作，即减少了访问磁盘的次数和需要传输的数据量，从而提高了查询效率和响应速度。
查询中所使用的索引类型和查询条件的限制，只有涉及到等值查询或范围查询的情况下，才能使用索引下推技术实现优化

SQL不走索引的原因：
1.索引字段使用函数或表达式‌：在索引列上应用函数或进行数学运算会导致索引失效，因为索引是基于原始列值的
2.连表的条件编码不一致
3.类型隐式转换,字段类型不一致，如String赋给了ID，会式调用cast方法
4.联合索引不满足最左匹配原则(条件必须是以联合索引的第一个索引为条件开始)
5.使用了select * ,全表扫描,查询效率低
6.索引列上有计算
7.like右边包含%
8.使用了or关键字(在使用or关键字时，切记两个条件都要添加索引，否则会导致索引失效)，使用了非优化逻辑操作符‌：如!=、<、>、NOT IN、NOT EXISTS、IS NOT NULL等操作符在查询条件中的使用会导致索引失效
9.优化器认为全表扫描 > 索引扫描 （数据量少的情况下）
10. order by 导致索引失效，全表数据进行排序处理


聚簇索引
    创建规则:
        如果表设置了主键，则主键就是聚簇索引
        如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引
        以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引
    注意事项:
        InnoDB的聚簇索引的叶子节点存储的是行记录（其实是页结构，一个页包含多行数据），InnoDB必须要有至少一个聚簇索引。
        由此可见，使用聚簇索引查询会很快，因为可以直接定位到行记录。
        如果查询条件为主键（聚簇索引），则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。
普通索引
    普通索引也叫二级索引，除聚簇索引外的索引，即非聚簇索引。
    InnoDB的普通索引叶子节点存储的是主键（聚簇索引）的值，而MyISAM的普通索引存储的是记录指针。
    叶子节点存储的是主键（聚簇索引）的值，而不是行记录

    如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树。
    第一次扫描通过普通索引定位到聚簇索引的值。
    第二次扫描通过聚簇索引的值定位到要查找的行记录数据。

