extends指上界通配符，示例中指的是所有类及其派生的子类
super指下界通配符，示例中指的是所有类及其超类。
?是通配符,泛指所有类型
T 代表一种类型

? extends T 指T类型或T的子类型
? super T   指T类型或T的父类型

？表示不确定的 java 类型
T (type) 表示具体的一个java类型
K V (key value) 分别代表java键值中的Key Value
E (element) 代表Elemen

开闭原则
对扩展开放，对修改关闭
依赖倒置
依赖抽象，不依赖具体
单一原则
保证功能的单一
接口隔离
各个接口分工明确，不使用一个总接口 各个接口不要相互污染
迪米特法则
不跟陌生人说话，不应该持有不属于他的引用
里氏替换原则
1.为什么要有里氏替换原则？
能再使用父类的地方透明的使用其子类。只有遵循里里氏替换原则才能达到这样的效果。
合成复用原则
能用组合（构造器传入引用）就用组合
尽量不要使用继承

1.为什么要有单例模式？
有些业务他规定的在jvm堆中只能有一个对象。
2.那么怎么实现单例
饿汉式
优点：执行效率高，性能高，没有任何的锁 缺点：某些情况下，可能会造成内存浪费
懒汉式
方法上加锁：性能差
双重检查锁：代码量比较大
静态内部类：比较简洁
注册式
枚举：其实就是静态代码块，而且是饿汉式，被官方推荐使用。
容器式：spring中的单例模式
ThreadLocal 线程中唯一
什么是序列化？什么是反序列化？
序列化：会把对象保存到磁盘上；
反序列化：就是把磁盘的对象读取到内存；
如果对象序列化之后，用这些方式，还是唯一的对象吗？
不是唯一的，如果想要唯一，添加readResolve方法，并且该方法返回原来的对象
反序列化有没有走构造函数？
反序列化不走构造函数。使用字节码重组的方式。
以上的单例模式中，哪些会被反射破坏，哪些会被序列化破坏？
只有枚举不能被反射和序列化破坏。
BeanFactory Runtime Rpc。

1. 饿汉式单例：在类加载就实例化，线程安全，执行效率比较高，但是不确定是否需要使用，造成内存浪费
2. 懒汉式单例：第一次调用进行初始化、线程不安全，需要通过synchronized或双重检查锁来实现线程安全
3. 反射破坏单例原理：虽然构造器设置为私有，但是可以通过设置强制访问来调用其构造函数，具体为：
c.setAccessible(true);
4. 序列化破坏单例原理：反序列化后的对象会重新分配内存，即重新创建
5. readResolve()方法防止反序列化破坏单例原理：在反序列化调用readObject()方法中，会先反序列化一个实
例，再进行判断是否定义了该方法，如果定义了该方法，则将刚才反序列化生成的对象进行覆盖。其实实际
上实例化了两次，只不过新创建的对象没有被返回
6. 枚举式单例模式：枚举式单例模式，无法通过反射及反序列化来破坏单例。无法通过反射破坏单例是因为jdk
底层做了限制，当发现反射调用的是枚举的构造器时，会抛出“”异常；无法反序列化来破环单例是因为反序列
化时如果该Enum类已被实例化则通过类名及类对象找到该枚举类并返回，所以不会产生多实例。是实现单例
模式最为优良的方式，并且《E៌ective Java》一书也推荐使用枚举来实现单例
7. 容器式单例模式：方便于管理众多的单例对象，但会出现线程安全问题，也会出现反射和反序列化破坏其单
例的现象，不过spring中的对象管理通过该方式

JDK动态代理跟CGLib动态代理的区别 (面试高频)
1. JDK动态代理通过反射去实现被代理对象的所有接口，所以JDK只能代理实现了接口的对象，CGLlib对代理类
所有方法重写
2. JDK动态代理跟CGLib代理都是在运行期生成新的字节码，但是CGLib实现更为复杂，用的是ASM框架，生成
代理类的效率比JDK低
3. JDK动态代理是通过反射机制去查询所有被代理对象的接口，CGLib代理是通过FastClass机制直接调用方法，
所有执行效率，CGLib比JDK代理要高
spring用的是哪个代理模式 bean有实现接口的时候用jdk，没有实现的话模式cglib
也可以强制用cglib

装饰器模式（结构）
代码特点：一定有一个构造函数的参数为当前类实现的接口类参数
也称为包装模式，是指不改变原有对象的基础上，将功能附加到对象上，提供了比继承更有弹性的替代方案，属于
结构型模式
装饰器模式的核心是功能扩展，主要包含四种角色
抽象组件：可以是接口或者抽象类，充当被装饰类的原始对象，规定了装饰对象的行为
具体组件：实现、继承抽象组件的一个具体对象，被装饰对象

1、装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你
还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职
责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或
者是其内部不想暴露出来。
2、装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给
一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；
3、装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进
行增强；

在BufferedReader中的构造方法中有Reader类，而FileReader的父类是InputStreamReader，
InputStreamReader父类是Reader。
这个的结构符合装饰器模式。

委派模式（行为型）
又叫委派模式，是一种面向对象的设计模式，允许对象组合实现与继承相同的代码重用！
基本作用是负责任务的调用和分配任务，是一种特殊的静态代理，可以理解为全权代理，但是也有一定的区别，等
下我们再分析下
优缺点：
委派能够将一个大型的任务细化，然后通过统一管理这些子任务的完成情况实现任务的跟进
缺点
增加复杂性

委派模式与代理模式的区别
委派模式与代理模式的区别：（拿领导、经理、员工来举例）
1、代理模式：领导 明确知道 我要找员工A干活，但是我不直接找员工A，我去找经理，让经理去找员工A；
重点：领导明确知道员工A的存在（代理对象代理时要传入被代理类），所以，经理也只会去找员工A（经理代理员
工A），类似于：一对一对一的关系； 2、委派模式：领导不关心有哪些员工，不需要知道员工，我直接说出我的
需求，去找经理，经理根据领导的需求去找能够干这个活的员工（如：加密就去找员工A、数据处理就去找员工
B）；
重点：领导不知道有哪些员工，领导只关心经理是谁以及他的需求是什么，只管去找经理，让他去找员工完成他的
事情，类似于：一对一对多的关系（员工是多个）

委派主要解决什么问题，什么情况下要委派。
答：将不同的任务分给不同的类，让不同的类职责变得单一，当任务比较大时，可以通过委派模式将任务分发给不
同的类执行。委派者不会做或者没有做该事情，而是把具体的事情交给了具体类。

策略模式（行为型）
行为型模式，面向对象的继承和多态机制，从而实现同一行为在不同场景下具备不同实现，并且结果相同
上次群里有同学讲的，我实现一个排序，可以用不同的排序算法！但是结果都是实现排序
1.符合开闭原则
2.避免使用多重条件转移语句，如if else
3.使用策略模式可以提高算法的保密性和安全性

缺点：
1.客户端必须知道所有的策略，并且自行决定使用哪一个策略类，这个也是跟委派模式的区别所在
2.会有多个策略类，增加维护难度

委派模式跟策略模式的区别
1策略模式必须知道所有的策略，然后再决定使用哪一种策略，策略的重点在于选择哪种方式，并且是可以相互替
代的，委派模式注重的是把任务下发下去
策略模式是委派模式内部的一种实现方式
自我理解：委派模式就是只有1个策略的策略模式！！

策略模式使用前提是什么？即满足什么条件你才能去选策略？真正用的时候
需要告诉客户端什么？当然你也可以按照约定实现策略。
答：某一种“算法”有多种实现时，可以抽象出算法的接口，所有策略实现该接口。真正使用时需要告诉用户有哪些
策略，让用户选择策略，或者在用户不选择的情况下选择默认策略

静态代理
动态代理
jdk动态代理
1.目标类一定要实现接口
2.通过目标类得到代理类，三个参数：1）类加载器，2）目标类实现的接口 3）InvocationHandler
3.生成的代理类是ỳnal修饰的
4.jdk只生成一个代理类文件
5.通过反射去调用方法
cglib动态代理
1.生成的代理类会去继承目标类
2.通过index去找到方法
3.cglib生成三个文件
生成代理类时jdk更快，cglib慢
调用时jdk用的反射，cglib用的fastClass机制通过index去定位，cglib会更快
jdk1.8之后（反射有了很大的优化）
cglib为什么要生成三个文件？
1.代理类的文件
2.先去找到我们的索引
3.通过索引定位到我们的方法
还有个继承了Factory
我们的代理类还能再被代理吗？
1.jdk代理后的类再次被jdk代理？
jdk不能再次被jdk代理，因为会造成handler调用死循环。如果使用不同的InvocationHandler可以，mybatis中的多重插件就是这么做的
2.jdk代理后的类再次被cglib代理？
jdk生成代理类是final，cglib生成代理类去继承目标类，所以不能被代理
3.cglib代理后的类再次被cglib代理？
会报方法名重复 Duplicate method name "newInstance" with signature
4.cglib代理后的类再次被jdk代理？
类的签名已经改变，没有目标方法了
只有jdk代理能再次被jdk代理，必须使用不同的InvocationHandler，其他都不可以
什么样类不能被代理？
1.对于jdk,必须有接口实现
2.final修飾的方法不能被cglib代理
3.方法不是public的
接口能够被代理吗？
接口能被代理，比如mybatis中的dao接口就是这样做

简单工厂
属于不属于23中设计模式
就一个工厂，负责所有对象创建，职责很重
工厂方法
建立更多的工厂，负责相应对象的创建，每一个实体对应一个工厂，工厂的职责更单一，但是类变多
抽象工厂
1.工厂抽象化
2.创建一个系列的产品

双亲委派
JVM类加载双亲委派，一个类加载器在加载类时，首先把请求委派给自己的父类加载器去执行。如果父类加载器还
存在父类加载器，就继续向上委派，直到顶层的启动类加载器，如果父类的加载器能够完成类加载，就成功返回，
如果父类加载无法完成加载，那么子加载器才会尝试自己去加载
BootstrapClassLoader（启动类加载器）
ExtClassLoader （标准扩展类加载器）
AppClassLoader（系统类加载器）
CustomClassLoader（用户自定义类加载器）

简单工厂
属于不属于23中设计模式
就一个工厂，负责所有对象创建，职责很重
工厂方法
建立更多的工厂，负责相应对象的创建，每一个实体对应一个工厂，工厂的职责更单一，但是类变多
抽象工厂
1.工厂抽象化
2.创建一个系列的产品

简单工厂模式是指由一个工厂对象创建出哪一种产品类的实例，属于创建型模式，何为创建型模式，就是指用于描
述“怎样创建对象”，GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。
后续还会讲结构性与行为型
结构型：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、
享元、组合等 7 种结构型模式。
行为型：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责 GoF
中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行
为型模式。
有一个工厂类，来决定传入的是什么对象类型，去创建那个对象类！！
为什么一定要用工厂模式，能够举出使用简单工厂比我直接 new Object() 到底有哪些好处？
答：
1. 在对象创建比较复杂的时候，工厂模式可以封装一些创建bean的方式，需要什么样的对象，通过工厂类获
取，不用重复造轮子，重复写构建对象的过程。降低代码耦合性，修改bean对象的创建，只在一个地方修改
即可。
2. 在不确定什么时候生成对象或者生成对象的方式不确定的时候，工厂方法可以延迟对象初始化比如Spring中
的ObjectFactory在循环依赖中的应用。
为什么又有一个工厂方法，它解决了简单工厂的哪个问题？
答：简单工厂的扩展，每次都需要修改工厂里的代码，当扩展比较多的时候，代码比较臃肿，耦合性比较高 工厂方
法，在扩展的时候，我只需要再添加新的实现即可，不影响别的。实际上工厂方法就是先定一个抽象接口，后面在
基于这个抽象接口定义对应的工厂Factory类。
抽象工厂模式
抽象工厂模式是指提供一个创建一系列相关或相关依赖对象的接口，无须指定具体的类！
抽象工厂缺点：
1. 规定了所有可能被创建的产品集合，扩展新的产品困难，需要修改抽象工厂接口
2. 增加了系统的抽象性和理解难度

Lock和synchronized的区别:
Lock：是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。
1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别
2.Lock 是一个接口，而 synchronized 是 Java 中的关键字， synchronized 是内置的语言实现。
3.synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。
4.Lock 可以让等待锁的线程响应中断(中断标识 interrupt)，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。
5.通过 Lock 可以知道有没有成功获取锁(holdLock方法)，而 synchronized 却无法办到。
6.Lock 可以通过实现读写锁提高多个线程进行读操作的效率。

synchronized的优势：
足够清晰简单，只需要基础的同步功能时，用synchronized。
Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即使出现异常，锁也能被自动释放。
使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。

21、ReentrantLock 和synchronized的区别
ReentrantLock是Java中的类 ：继承了Lock类，可重入锁、悲观锁、独占锁、互斥锁、同步锁。
相同点：
1.主要解决共享变量如何安全访问的问题
2.都是可重入锁，也叫做递归锁，同一线程可以多次获得同一个锁，
3.保证了线程安全的两大特性：可见性、原子性。
不同点：
1.ReentrantLock 就像手动汽车，需要显示的调用lock和unlock方法， synchronized 隐式获得释放锁。
2.ReentrantLock 可响应中断， synchronized 是不可以响应中断的，ReentrantLock 为处理锁的不可用性提供了更高的灵活性
3.ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的
4.ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁，synchronized 是非公平锁，且不可更改。
5.ReentrantLock 通过 Condition 可以绑定多个条件

悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升

unsafe： 获取并操作内存的数据。
valueOffset： 存储value在AtomicInteger中的偏移量。
value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

需要读写的内存值 V。
进行比较的值 A。
要写入的新值 B。
当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：

ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。

多线程的好处:
1.使用线程可以把占据时间长的程序中的任务放到后台去处理
2.用户界面更加吸引人,这样比如用户点击了一个按钮去触发某件事件的处理,可以弹出一个进度条来显示处理的进度
3.程序的运行效率可能会提高
4.在一些等待的任务实现上如用户输入,文件读取和网络收发数据等,线程就比较有用了.

多线程的缺点:
1.如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换.
2.更多的线程需要更多的内存空间
3.线程中止需要考虑对程序运行的影响.
4.通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生
为了解决负载均衡问题,充分利用CPU资源.为了提高CPU的使用率,采用多线程的方式去同时完成几件事情而不互相干扰.为了处理大量的IO操作时或处理的情况需要花费大量的时间等等,
比如:读写文件,视频图像的采集,处理,显示,保存等

单线程与多线程的区别
单线程程序：只要一个线程，代码次序履行，容易出现代码堵塞（页面假死）
多线程程序：有多个线程，线程间独立运转，能有效地防止代码堵塞，并且进步程序的运转功能
1 、 在单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。
2 、 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。
结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。

线程的上下文切换
利用了时间片轮转的方式, CPU 给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。
时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。

Current Running Thread：当前正在运行的线程
Save Context：保存当前线程状态
Restore Context：恢复下个线程

上下文
是指某一时间点 CPU 寄存器和程序计数器的内容。
寄存器
是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。

程序计数器
是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。

上下文切换的活动
挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。
跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。
引起线程上下文切换的原因
当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务；
当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；
多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；
用户代码挂起当前任务，让出 CPU 时间；
硬件中断；

Java堆和栈的区别
栈：运行时单位，代表逻辑，内含基本数据类型和堆中的对象引用，所在区域连续，没有碎片；
堆：存储单元，代表着数据，可以被多个栈共享，所在区域不连续，有碎片；
区别:
1、功能不同：栈内存用来存储局部变量和方法调用，而堆内存用存储Java中的对象；无论是成员变量、局部变量、还是类变量他们指向的对象都存储在堆内存中；
2、共享性不同：栈是线程私有，而堆是线程共享；
3、异常错误不同：当内存不足时；栈抛出的是StackOverFlowError异常，而堆抛出的是OutOfMemoryError；
4、空间大小不同：堆空间大小远远大于栈的内存空间。

什么是竞态条件？ 举个例子说明。
1、什么是竞态条件？
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
导致竞态条件发生的代码区称作临界区。
在临界区中使用适当的同步就可以避免竞态条件。
临界区实现方法有两种，一种是用synchronized，一种是用Lock显式锁实现。
竞态条件是指同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件，代码区成为临界区。
最常见的竞态条件为：先检测后执行。执行依赖于检测的结果，而检测结果依赖于多个线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现各种问题。

什么是竞态条件？你怎样发现和解决竞争？
当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。
在临界区中使用适当的同步就可以避免竞态条件。
界区实现方法有两种，一种是用 synchronized ，一种是用 Lock 显式锁实现。

线程类的构造方法
静态块是被new这个线程类所在的线程所调用的
而run方法里面的代码才是被线程自身所调用的。


ps -ef | grep java
top -H -p pid


ConcurrentHashMap 的并发度是什么 ?
ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，
这也是ConcurrentHashMap 对 Hashtable 的最大优势，任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗


一.CountDownLatch 和 CyclicBarrier的区别
CountDownLatch 的计数器是大于或等于线程数的，而CyclicBarrier是一定等于线程数
CountDownLatch 放行由其他线程控制而CyclicBarrier是由本身来控制的

FutureTask是什么
FutureTask 表示一个异步运算的任务。 FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这
个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask

生产者消费者模型的作用是什么
1 、通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型
最重要的作用
2 、解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可
以独自发展而不需要收到相互的制约

ReadWriteLock是什么
首先明确一下，不是说 ReentrantLock 不好，只是 ReentrantLock 某些时候有局限。如果使用ReentrantLock ，可能本身是为了防止线程 A 在写数据、线程 B 在读数据造成的数据不一致，但这样，如
果线程 C 在读数据、线程 D 也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降
低了程序的性能。
因为这个，才诞生了读写锁 ReadWriteLock 。 ReadWriteLock 是一个读写锁接口，
ReentrantReadWriteLock 是 ReadWriteLock 接口的一个具体实现，实现了读写的分离，读锁是共享的，
写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。

死锁避免与死锁检测方法
死锁问题被认为是线程/进程间切换消耗系统性能的一种极端情况。在死锁时，线程/进程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是任务永远无法执行完成。
一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。这样会出现一种操作“无反应”的结果。

死锁产生的4个必要条件？
产生死锁的必要条件：
互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。

死锁避免方法：
1、加锁时序
2、加锁时限
3、死锁检测

死锁和活锁
所谓死锁，其实就是“集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。”死锁，即意味着程序已经无法继续工作，大量的计算机资源被浪费。死锁形成需要以下条件：
1、互相持有
就是A进程持有B进程需要继续工作的资源，反过来，B进程同时也持有A进程需要继续工作的资源。
2、循环等待
这个好理解，就是两个进程间互相需要对方的资源，而且不断等待着对方资源。
3、不可剥夺
和优先级一样，不能够一个进程强行从另外一进程把需要的资源强制夺取过来
4、资源互斥
活锁（liveLock），指线程间资源冲突激烈，引起线程不断的尝试获取资源，不断的失败。活锁有点类似于线程饥饿，虽然资源并没有被别人持有，但由于各种原因而无法得到。最常见的原因是进程组的执行顺序不合理，导致某些先需要的资源被后置。活锁和死锁的不同在于，活锁的状态是变化的，只是无法达到目的。活锁有可能在一定时间后自动解开，但死锁不能。

如何在两个线程之间共享数据
1，如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，卖票系统就可以这么做。
2，如果每个线程执行的代码不同，这时候需要用不同的Runnable对象，例如，设计4个线程。其中两个线程每次对j增加1，另外两个线程对j每次减1，银行存取款


线程池submit() 和 excute()区别
1、submit在执行过程中与execute不一样，不会抛出异常而是把异常保存在成员变量中，在FutureTask.get阻塞获取的时候再把异常抛出来。
2、Spring的@Schedule注解的内部实现就是使用submit，因此，如果你构建的任务内部有未检查异常，你是永远也拿不到这个异常的。
3、execute直接抛出异常之后线程就死掉了，submit保存异常线程没有死掉，因此execute的线程池可能会出现没有意义的情况，因为线程没有得到重用。而submit不会出现这种情况。

1、接收的参数不一样
2、submit有返回值，而execute没有

用到返回值的例子，比如说我有很多个做validation的task，我希望所有的task执行完，然后每个task告诉我它的执行结果，是成功还是失败，如果是失败，原因是什么。然后我就可以把所有失败的原因综合起来发给调用者。
个人觉得cancel execution这个用处不大，很少有需要去取消执行的。

而最大的用处应该是第二点。

3、submit方便Exception处理
意思就是如果你在你的task里会抛出checked或者unchecked exception，
而你又希望外面的调用者能够感知这些exception并做出及时的处理，那么就需要用到submit，通过捕获Future.get()抛出的异常。
Future.get()在执行成功后返回的值是null

同步：提交请求->等待服务器处理->处理完返回 这个期间客户端浏览器不能干任何事
异步：请求通过事件触发->服务器处理（这时浏览器仍然可以做其他事情）->处理完毕
Java中的那个共享数据同步（synchronized）一个同步的对象是指行为（动作），一个同步的对象是指物质（共享数据）。

如何控制某个方法允许并发访问线程的个数
Semaphore

线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况


wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别
wait() 方法立即释放对象监视器，
notify()/notifyAll() 方法则会等待线程剩余代码执行完毕才会放弃对象监视器。

多线程——Executor、ExecutorService、Executors三者的区别
区别：
　　1.ExecutorService 接口继承了Executor 接口，是Executor 的子接口。
　　2.Executor接口中定义了execute()方法，用来接收一个Runnable接口的对象，
　　  　　 而ExecutorService接口中定义的submit()方法可以接收Runnable和Callable接口对象。
　　3.Executor接口中execute()方法不返回任何结果，而ExecutorService接口中submit()方法可以通过一个 Future 对象返回运算结果。
　　4.Executor和ExecutorService除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。
　　   　　比如：调用 shutDown() 方法终止线程池。
　　5.Executors 类提供工厂方法用来创建不同类型的线程池。比如:
　　 　Executors.newSingleThreadExecutor() 创建一个只有一个线程的线程池，
　　　 Executors.newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，
　　    Executors.newCachedThreadPool()创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
　　    Executors.newScheduledThreadPool(int corePoolSize) 创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。

ThreadLocal的应用场景
场景1：
ThreadLocal 用作保存每个线程独享的对象，为每个线程都创建一个副本，这样每个线程都可以修改自己所拥有的副本, 而不会影响其他线程的副本，确保了线程安全。
场景2：
ThreadLocal 用作每个线程内需要独立保存信息，以便供其他方法更方便地获取该信息的场景。每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念。

典型场景1
这种场景通常用于保存线程不安全的工具类，典型的需要使用的类就是 SimpleDateFormat。


同步方法和同步块，哪个是更好的选择
同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条
原则：同步的范围越小越好。
借着这一条，我额外提一点，虽说同步的范围越少越好，但是在 Java 虚拟机中还是存在着一种叫做锁粗
化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说 StringBuffer ，它是一个线程安全
的类，自然最常用的 append() 方法是一个同步方法，我们写代码的时候会反复 append 字符串，这意味
着要进行反复的加锁 -> 解锁，这对性能不利，因为这意味着 Java 虚拟机在这条线程上要反复地在内核态
和用户态之间进行切换，因此 Java 虚拟机会将多次 append 方法调用的代码进行一个锁粗化的操作，将多
次的 append 的操作扩展到 append 方法的头尾，变成一个大的同步块，这样就减少了加锁 --> 解锁的次
数，有效地提升了代码执行的效率。


程序：一组计算机能识别和执行的指令、它是一些保存在磁盘上的指令的有序集合

进程：进程是一个独立的可调度的任务，进程是一个抽象的实体，当系统在执行某个程序时，分配和释放的各种资源，进程是资源分配的总称。

线程：共享同一个进程地址空间的多个任务叫线程


HashTable、Vector、StringBuffer线程安全的原因
HashTable线程安全的原因：put方法是synchronized的所以可以保证其线程安全
Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe),但有些时候，也甭保证
虽然源代码注释里面说这个是线程安全的，因为确实很多方法都加上了同步关键字synchronized，但是对于符合操作而言，
只是同步方法并没有解决线程安全的问题。
要真正达成线程安全，还需要以vector对象为锁，来进行操作。


解决高并发幕等性问题:一锁二判三更新

AQS 全称是 AbstractQueuedSynchronizer，它是 J.U.C 包中 Lock 锁的底层实
现，可以用它来实现多线程的同步器！
AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、CountDownLatch、Semaphore 等都用到了 AQS.
从本质上来说，AQS 提供了两种锁机制，分别是排它锁，和共享锁。排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该
共享资源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的ReentrantLock 重入锁实现就是用到了 AQS 中的排它锁功能。
共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。

JMM层面可见性:
jmm(Java Memory Model):内存模型与线程规范,java内存模型围绕着并发过程中如何处理可见性,原子性,有序性这三个特性而建立的模型
内存模型主要是描述程序中各个变量之间的关系,以及在实际计算机系统中将变量存储到内存和从内存中取出变量到底层细节
主内存(Main Memory)：JMM规定所有的变量存储在主内存中,每个线程还有自己的工作内存(Working Memory)

JMM是一个抽象等内存模型，他定义了共享内存中多线程程序读写操作的行为规范，在虚拟机中把共享变量存储到内存以及从内存中取出共享变了的底层实现
原理，通过这些规范来规范对内存对读写操作从而保证指令的正确性，解决了cpu多级缓存，处理器优化，指令重排序导致的内存访问问题，
保证了并发场景下的可见性


1.CAS——读多写少
对于资源竞争较少（线程冲突较轻）的情况

此时如果使用synchronized，那么用户态、内核态的频繁切换会耗费很多资源；
CAS自旋几率小，性能更高。
2.Synchronized——写冲突多，强一致性的场景
写入频繁的场景，线程冲突严重。

此时CAS自旋概率大，会浪费更多CPU资源。
3.ReentrantLock
synchronized的锁升级是不可逆的。

如果是一个打车软件，那过了打车高峰期，还是重量级锁，就会降低效率；此时如果用Reentratlock就比较好。
Lock（注意不是Reentrantlock）可以使用读锁，来提升多线程的读效率。
而且Reentrantlock支持绑定Condition条件，实现线程的精确唤醒。
lock
支持以非阻塞方式获取锁
可以响应中断
可以限时
支持了公平锁和非公平锁
ReentrantLock获取锁的几种方式：
ReentrantLock共有4中获取锁的方式：
1、lock 2、lockInterruptibly() throws InterruptedException
3、tryLock 4、tryLock(long timeout, TimeUnit unit) throws InterruptedException


1.7 hashmap 线程不安全:多线程环境下会发生数据覆盖的情况 resize的时候会死循环 头插法



hashmap chm区别:加锁不加锁的区别,chm不允许key为null

1.8 hashmap 当单链表长度大于8数组长度64时升级为红黑树,红黑树深度不够6时将为数组加链表
1.7使用的时分段锁机制,锁住的时segment数组,采用重入锁reentrantlock
1.8采用的是node+cas+synchronized来保证并发安全性,取消segment直接锁住entry （颗粒度降低,在大量数据操作下对于jvm的内存压力,基于
api的reentrantlock会有更多开销）


装载因子 0.75

HashTable和HashMap区别
      1、继承的父类不同
      Hashtable继承自Dictionary类，而HashMap继承自AbstractMap类。但二者都实现了Map接口。
      2、线程安全性不同
      3、是否提供contains方法
            HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey，因为contains方法容易让人引起误解。
            Hashtable则保留了contains，containsValue和containsKey三个方法，其中contains和containsValue功能相同
      4、key和value是否允许null值

 Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。
HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

      5、两个遍历方式的内部实现上不同
      Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

      6、hash值不同
      哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
      7、内部实现使用的数组初始化和扩容方式不同
            HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。
            Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。
            Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。


           HashMap不是线程安全的，HashTable是线程安全。
           HashMap允许空（null）的键和值（key），HashTable则不允许。
           HashMap性能优于Hashtable。







reids Reactor设计模式
sql nosql区别:
数据结构 结构化 ,  ⾮结构化
数据关系 关联 ,  ⾮关联
查询⽅式 sql ⾮sql , 输⼊key 查询value
事务性 ACID , CAP BASE
A ：原⼦性，C：⼀致性 I ：隔离 D 持久型
CAP ： C ⼀致性 A 可⽤性 P：分区容忍 AP
sql 数据库：复杂业务，表有关联性，
nosql 数据库： 业务复杂：1， 业务不复杂：0
读取能⼒强， key -value ，书 ⻚码

Remote Dictionary Server，远程词典服务
器，是⼀个基于内存的键值型NoSQL数据库key-value 内存

业务场景：
业务发展，数据量，并发量，客户访问量增⼤。 系统正在更多的数据，
并发量。
磁盘 IO ， 内存，
秒杀、需要被频繁访问的数据，同时需要提供良好的⽤户体验。
特征：
⾼性能： 内存，IO 多路复⽤， 读写分离，数据分⽚
⼀致性：单线程、命令 原⼦性 setnx lua 脚本，分布式锁。redis
可⽤性：⽀持持久化，写磁盘（RDB AOF），哨兵机制（Leader 选举），监控，主选举。
(脑裂 官方定义:当一个集群的不同部分在同一时间都认为自己是活动的时候,我们就可以将这个现象称为脑裂症状。)
灵活性：key-value，⽀持多种类型

Keys:
Del: 删除key
exists：是否存在key
expire：设置key的过期时间
ttl： 查看key的剩余的有效期


AOF⽂件重写
执⾏ bgrewriteaof 命令， 对⽂件执⾏重写
⽂件重写的⽬的是为了节省⽂件的空间


主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理
但Redis的其他功能，比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。Redis工作线程是单线程的，但是，整个Redis来说，是多线程的。



Redis单线程为什么快
(1) 基于内存操作：Redis 的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高；
(2) 数据结构简单：Redis 的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是 O(1)，因此性能比较高；
(3) 多路复用和非阻塞 I/O：Redis使用 I/O多路复用功能来监听多个 socket连接客户端，这样就可以使用一个线程连接来处理多个请求，
减少线程切换带来的开销，同时也避免了 I/O 阻塞操作;
(4) 避免上下文切换：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，
而且单线程不会导致死锁问题的发生;

I/O 多路复用
这是IO模型的一种，即经典的Reactor设计模式，
I/O 多路复用，简单来说就是通过监测文件的读写事件再通知线程执行相关操作，保证 Redis 的非阻塞 I/O 能够顺利执行完成的机制。
多路指的是多个socket连接，
复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。
epoll是最新的也是目前最好的多路复用技术。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），
且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。

在 Redis 6.0 中新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，
这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），
将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。
网络IO操作就变成多线程化了，其他核心部分仍然是线程安全的，是个不错的折中办法。

在Redis6.0中，多线程机制默认是关闭的，如果需要使用多线程功能，需要在redis.conf中完成两个设置。
 设置io-thread-do-reads配置项为yes，表示启动多线程。
2 设置线程个数。关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，
如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。

4 单节点Redis的问题
数据丢失问题：实现Redis 数据持久化
并发能⼒问题：主从集群，实现读写分离
存储能⼒问题：分⽚集群，利⽤插槽机制实现动态扩容
故障恢复问题：利⽤Redis 哨兵，实现健康检测和⾃动恢复



RocketMQ 应用场景
流量削峰：在高并发的下单请求达到的时候，于是就将请求存放到队列中。
异步处理：提升了效率和响应时间。下单后有很多后续处理，异步的方式处理请求。
服务解耦：订单、付款、评分 将组件 服务之间 减少依赖。

集群工作流程：
启动NameServer， 监听端口 Broker、Producer、Consumer 连接上路由的注册中心。
Broker启动，会和NameServer保持一个长链接，定时发送心跳包。
NameServer 对Broker进行注册。成功以后就有Topic 和Broker的映射关系了。
收消息和发送消息之前，创建topic （order）
Producer 发送之前先获取NameServer topic 和broker 信息。
Consumer 链接NameServer ，订阅Topic Broker，链接Broker 创建通道，开始消费消息

name server 启动过程，broker server 启动过程，producer 发送消息，consumer 接收消息。




如何知道有消息丢失？
在消息生产端，给每个发出的消息都指定一个全局唯一ID，或者附加一个连续递增的版本号，然后在消费端做对应的版本校验。
你可以利用拦截器机制。 在生产端发送消息之前，通过拦截器将消息版本号注入消息中（版本号可以采用连续递增的 ID 生成，
也可以通过分布式全局唯一 ID生成）。然后在消费端收到消息后，再通过拦截器检测版本号的连续性或消费状态，
这样实现的好处是消息检测的代码不会侵入到业务代码中，可以通过单独的任务来定位丢失的消息，做进一步的排查。

这里需要你注意：如果同时存在多个消息生产端和消息消费端，通过版本号递增的方式就很难实现了，
因为不能保证版本号的唯一性，此时只能通过全局唯一 ID 的方案来进行消息检测，
具体的实现原理和版本号递增的方式一致。


哪些环节可能丢消息？

如何确保消息不丢失？
在消息消费的过程中，如果出现失败的情况，通过补偿的机制发送方会执行重试，重试的过程就有可能产生重复的消息，那么如何解决这个问题？
这个问题其实可以换一种说法，就是如何解决消费端幂等性问题（幂等性，就是一条命令，任意多次执行所产生的影响均与一次执行的影响相同），只要消费端具备了幂等性，那么重复消费消息的问题也就解决了。
我们还是来看扣减京豆的例子，将账户 X 的金豆个数扣减 100 个，在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。
最简单的实现方案，就是在数据库中建一张消息日志表， 这个表有两个字段：消息 ID 和消息执行状态。这样，我们消费消息的逻辑可以变为：在消息日志表中增加一条消息记录，然后再根据消息记录，异步操作更新用户京豆余额。

因为我们每次都会在插入之前检查是否消息已存在，所以就不会出现一条消息被执行多次的情况，这样就实现了一个幂等的操作。当然，基于这个思路，不仅可以使用关系型数据库，也可以通过 Redis 来代替数据库实现唯一约束的方案。

在这里我多说一句，想要解决“消息丢失”和“消息重复消费”的问题，有一个前提条件就是要实现一个全局唯一 ID 生成的技术方案。这也是面试官喜欢考察的问题，你也要掌握。《分布式ID生成器的解决方案总结》这篇建议看下。

在分布式系统中，全局唯一 ID 生成的实现方法有数据库自增主键、UUID、Redis，Twitter-Snowflake 算法


消息生产阶段： 从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 MQ Broker 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，这个阶段是不会出现消息丢失的。
消息存储阶段： 这个阶段一般会直接交给 MQ 消息中间件来保证，但是你要了解它的原理，比如 Broker 会做副本，保证一条消息至少同步两个节点再返回 ack。
消息消费阶段： 消费端从 Broker 上拉取消息，只要消费端在收到消息后，不立即发送消费确认给 Broker，而是等到执行完业务逻辑后，再发送消费确认，也能保证消息的不丢失。

如何确保消息不会丢失？
你要知道一条消息从发送到消费的每个阶段，是否存在丢消息，以及如何监控消息是否丢失，
最后才是如何解决问题，方案可以基于“ MQ 的可靠消息投递 ”的方式。

如何保证消息不被重复消费？
在进行消息补偿的时候，一定会存在重复消息的情况，那么如何实现消费端的幂等性就这道题的考点。

如何处理消息积压问题？
这道题的考点就是如何通过 MQ 实现真正的高性能，回答的思路是，本着解决线上异常为最高优先级，
然后通过监控和日志进行排查并优化业务逻辑，最后是扩容消费端和分片的数量。

什么是RabbitMQ？
RabbitMQ简称MQ是一套实现了高级消息队列协议的开源消息代理软件，简单来说就是一个消息中间件。
是一种程序对程序的通信方法
，其服务器也是以高性能、健壮以及可伸缩性出名的Erlang语言编写而成。
RabbitMQ是干什么的？
答：RabbitMQ简单来说就是一个消息队列中间件，用来保存消息和传递消息的一个容器。
在此过程中充当一个中间人的作用。
kafka和rabbitmq的区别
Rabbitmq比kafka可靠，kafka更适合IO高吞吐的处理，比如ELK日志收集

Kafka和RabbitMq一样是通用意图消息代理，他们都是以分布式部署为目的。但是他们对消息语义模型的定义的假设是非常不同的。

a) 以下场景比较适合使用Kafka。如果有大量的事件(10万以上/秒)、你需要以分区的，顺序的，至少传递成功一次到混杂了在线和打包消费的消费者、希望能重读消息、你能接受目前是有限的节点级别高可用就可以考虑kafka。

b) 以下场景比较适合使用RabbitMQ。如果是较少的事件（2万以上/秒）并且需要通过复杂的路由逻辑去找到消费者、你希望消息传递是可靠的、并不关心消息传递的顺序、而且需要现在就支持集群-节点级别的高可用就可以考虑rabbitmq。

为什么要使用rabbitMq呢？
mq是异步的，性能高
缺点：不过使用mq，会导致系统可用性降低，复杂度提高。系统本身的外部依赖越多越容易挂掉，如果系统好好地，
但是mq划掉的，整个项目就用不了了。还有如果硬生生加进来一个mq，还要考虑怎么保证数据的一致性，
如果一个系统处理完数据后结果返回成功了，但是系统其他系统有一个报错了，数据就会不一致。，有没有重复性消费，如果数据丢失了怎么办。

RabbitMQ的特点
1、可靠性：RAbbitMQ使用一些机制来保证消息可靠性，如持久化，传输确认以及发布确认；
2、灵活的路由：在消息进入队列之前，通过交换机来路由信息；
3、扩展性：多个RabbitMQ可以组成一个集群，，也可以根据业务情况动态的扩展集群中的节点；
4、多语言客户端：RabbitMQ支持非常多的语言，如Java，Python，Ruby，PHP，C#,JavaScript等；
5、管理界面：RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息和集群中的节点等；
6、插件机制：RabbitMQ提供了许多插件，实现从多方面进行扩展，也可以编写自己的插件。

消息队列——AMQP的理解：
AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。
生产者Publisher生产消息发送到交换机Exchange，由交换机分发到指定的队列Queue存储，然后消费者Consumer 从队列获取消息进行消费。
即高级消息队列协议，规范客户端与消息中间件服务器之间的通信，并能相互操作。
AMQP协议的作用

降低应用程序之间的耦合度，这样不同应用之间的集成的难度将变得更小，并开发出更有用的应用程序 。

3.AMQP协议的模型

包含三个成员：Exchange,Message Queue,Binding

Exchange:转换成员，是接收应用程序发过来的信息，但通过Binding这个路由规则，路由到对应的Message Queue中

Message Queue:这个是存储实际队列的内容

Binding:定义Exchange与Message Queue这间绑定的路由规则

AMQP协议分了三层：
　　Model Layer（模型层）
   　　 规范服务器端Broker的行为。
　　Session Layer（会话层）
   　　 定义客户端与服务器端Broker的Context。
　　Transport Layer（传输层）
   　　 传输二进制数据流。

5.AMQP的工作原理
AMQP服务器Broker主要由Exchange和Message Queue组成，主要功能是Message的路由Routing和缓存Buffering。
生产者发送消息的流程
1. 生产者连接 RabbitMQ ，建立 TCP 连接 ( Connection) ，开启信道/通道（ Channel ）

2. 生产者声明一个 Exchange （交换器），并设置相关属性，比如交换器类型、是否持久化等

3. 生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等

4. 生产者通过 bindingKey （绑定 Key ）将交换器和队列绑定（ binding ）起来

5. 生产者发送消息至 RabbitMQ Broker ，其中包含 routingKey （路由键）、交换器等信息

6. 相应的交换器根据接收到的 routingKey 查找相匹配的队列。

7. 如果找到，则将从生产者发送过来的消息存入相应的队列中。 如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者

8. 关闭信道。

9. 关闭连接。

消费者获取消息的过程
1. 消费者连接到RabbitMQ Broker，建立一个连接(Connection )，开启一个信道(Channel) 。

2. 消费者向 RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，以及 做一些准备工作

3. 等待 RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息。

4. 消费者确认 ( ack) 接收到的消息。

5. RabbitMQ 从队列中删除相应己经被确认的消息。

6. 关闭信道。

7. 关闭连接。

Connection和Channel
在上面提到的流程里面频繁频繁在第一步出现Connection和Channel，所以这里讲一下这两者有啥用，有啥关系

关系
生产者和消费者，需要Connection与RabbitMQ Broker建立起TCP连接，一旦连接建立起来之后，客户端会随之创建一个AMQP通道，也就是Channel，每个通道都会被标记上一个唯一的ID，通道是建立在Connection之上的虚拟连接，所以说，RabbitMQ处理的每一条AMQP指令都是通过通道Channel完成的

疑问
上面关系中提到，会建立TCP连接，那为什么后面不用TCP而是用通道进行连接呢？

解答
因为RabbitMQ采用了NIO的做法，复用TCP连接，从而减少性能的开销，而且便于管理，

1、当每个通道的流量不是特别大的时候，使用复用技术，复用单一的Connection可以在产生性能瓶颈的情况下节省TCP连接资源

2、如果当通道的流量很大的时候，一个Connection就会产生性能瓶颈，流量就会被限制，这个时候就需要建立多个Connection，分摊通道，具体怎么分摊，就看业务需求了
rabbitMq的高可用
1、rabbitMq有三种模式，单机模式，普通集群模式，镜像集群模式。

普通集群，消费者随机从一个实例中获取数据，如果这个队列的实例宕机了，只能等实例恢复后，才能重新消费。

镜像集群，在mq控制管理后台添加镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。每个rabbitMq节点都有队列的完整镜像，每次写消息的时候，都会将消息同步到多个实例的queue上。

4、日志追踪
firehose,tracing

使用Haproxy实现负载均衡
HAProxy提供高可用性，负载均衡及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费快速并且可靠的一种解决方案，有许多知名的互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。
demo是在docker上运行3个容器组成的RabbitMQ集群，运行一个Haproxy的容器进行负载均衡。
消息存储机制
　　不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。持久化的消息在到达队列时就被写入到磁盘，非持久化的消息一般只保存在内存中，在内存吃紧的时候会被换入到磁盘中，以节省内存空间。这两种类型的消息的落盘处理都在 RabbitMQ 的“持久层”中完成。
　　持久层是一个逻辑上的概念，实际包含两个部分：
（1）队列索引（rabbit_queue_index）
　　rabbit_queue_index 负责维护队列中落盘消息的信息，包括消息的存储地点、是否已被交付给消费者、是否已被消费者 ack 等。每个队列都有与之对应的一个 rabbit_queue_index。
（2）消息存储（rabbit_msg_store）
　　rabbit_msg_store 以键值对的形式存储消息，它被所有队列共享，在每个节点中有且只有一个。
从技术层面上来说，rabbit_msg_store 具体还可以分为：
<1>msg_store_persistent：负责持久化消息的持久化，重启后消息不会丢失
<2>msg_store_transient：负责非持久化消息的持久化，重启后消息会丢失。

rabbitMQ 简介：
开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据。
RabbitMq是使用Erlang语言来进行编写。并且RabbitMq基于AMQP协议。

RabbitMq高性能的原因：
Erlang语言最初是用于交换机领域的架构模式，这使得RabbitMQ在Broker之间进行数据交互的性能是非常优秀的。
Erlang语言的优点：Erlang有着和原生Socket一样的延迟。

AMQP协议： Advanced Message Queuing Protocol 高级消息队列协议
AMQP定义：具有现代特征的二进制协议，是一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。
发布者发送message到exchange（exchange就像邮局或电子邮箱），exchange再通过bindings规则分发message到queue，然后broker再传递message给订阅了queue的消费者，或者消费者从需要的queue中获取/拉取message

1、broker

它是RabbitMQ消息中间件的代理，或者说它就是RabbitMQ的具体实体

2、exchange

它是消息发送的具体实体，负责拿到message并路由到queue

在RabbitMQ中，根据不同分发需要exchange分为四种类型：

（1）Direct exchange，默认类型

当使用此exchange时，发送方的key与queue绑定的key必须完全匹配，则分发成功

（2）Fanout exchange，广播类型

当使用此exchange时，发送方的key为空，queue不需要绑定key，则分发成功

（3）Topic exchange，主题类型

当使用此exchange时，发送方的key与queue绑定的key必须模糊匹配，则分发成功

（4）Headers exchange，头类型（3.8以上版本新增类型）

当使用此exchange时，发送方的headers参数必须与queue绑定的key必须部分或完全匹配，则分发成功

3、queue

它是消息队列的具体实体，负责消息缓冲、入队和出队

4、message

它是消息本身的具体实体，负责消息封装

5、connection

它是发送方、接收方与RabbitMQ消息中间件之间建立连接的具体实体，负责建立授信的TCP长连接

6、channel

它是共享connection的轻量级连接的具体实体，负责在一个connection中建立多个并行的通信通道

7、bindings

它是exchange分发到queue的规则，负责在exchange和queue之间建立逻辑映射

死信：

当消息过期，超时无人消费；要投递的消息满了，无法投递；消费者使用basic.reject或basic.nack声明消费失败，并且消息的request参数设置为false。
RabbitMQ中消息message的三种状态
Ready：待消费的消息总数。
Unacked：待应答（待确认）的消息总数。
Total：总数 Ready+Unacked。

RocktMQ 有两个触发点来触发路由删除 。
NameServer 检测broker心跳包
Step1: 启动线程定时扫描不活跃的broker
Step2:	扫描不活跃的broker
上次收到心跳包的时间如果超过当前时间 l20s, NameServer则认为该 Broker已不可用， 故需要将它移除，关闭 Channel，然后删除与该 Broker相关的路由信息，路由表维护过程， 需要申请写锁 。

NameServer路由发现
ocketMQ 路由发现 是非实 时的，当 Topic 路由 出现变化后， NameServer不主动推送给客户端 ， 而 是由客户端定时拉取主题最新的路由

Producer 消息发送方式
同步：发送者向 MQ 发送消息的时候，会进行同步等待。等待到消息服务器（broker）返回结果。
异步：发消息发送的 API 执行完毕以后就返回，等待消息结果响应才执行回掉函数。生产者的线程
不阻塞。
单向：调用 API 发送消息以后就直接返回。不等结果，没有回掉函数。

Producer 消息结构
Message 属性：
Topic：主题
Flag：RocketMQ 不做处理，不用关心
Properties：扩展属性
Body：消息体
Message 扩展属性：Message 的 properties 保存
tag:消息 TAG，用于消息过滤 。
keys: Message 索引键， 多个用空格隔开， RocketMQ 可以根据这些 key 快速检索到消息 。
waitStoreMsgOK:消息发送时是否等消息存储完成后再返回 。
delayTimeLevel: 消息延迟级别，用于定时消息或消息重试 。

Producer 启动过程
普通发送者：DefaultMQProducer（boss），是需要构建一个 Netty 客户端往 Broker 发送消息就行
了。DefaultMQProducerImpl（打工仔）
当 Producer 启动的时候只知道 topic 而不知道 broker address

rocket作为开源消息中间件的佼佼者，其性能及稳定性得到业界普遍的认可；rocketmq的数据安全设计一共可分为两种类型：同步刷盘、异步刷盘。同步刷盘，每一条消息的发送都确认写入磁盘才确保消息发送成功。异步刷盘，按照预先定义的逻辑，间隔时间进行写入磁盘，允许部分数据丢失。二种方式各有优缺点，同步刷盘做到了数据的绝对安全，但是牺牲了部分性能为代价，异步刷盘做到了数据的相对安全，同时保证了数据发送接收的效率。

解决我们MySQL在生产环境遇到的常见问题，如果你想要解决我们生产环境遇到的问题，那么你就得了解一个SQL语句的执行流程，这样你才能具体问题具体分析。
MySQL客户端与服务端通讯
一条语句在执行之前是需要 创建连接的，需要建立连接，那么在MySQL中肯定
是有一个地方能够帮我们管理连接，和创建连接的是吧?
MySQL单个客户端跟服务器的通讯在任何一个时刻，都是不能同时发生的，要
么客户端向服务器发送数据，要么服务器向客户端发送数据！因为我们通信方式是半
双工的，所以我们的SQL执行之后只能等待服务端的返回，如果SQL执行效率过低，
会延缓查询时间，降低系统的吞吐量。我们要对SQL进行优化也是这个原因。

查询缓存（8.0移除）
查询才有， 如果命中缓存，后面的步骤不会执行局限性非常大，它是以查询语句，并且大小写敏感的的哈希值查找实现的，只要多一
个字符，哪怕是空格，或者大小写不完全一致，就不会走到查询缓存！并且包含不确定的函数也不会缓存，比如now()
如果查询命中缓存，后续的流程都不会走，但是因为不好用，因为是根据sql语句完成相同才会有用，所以使用场景有局限性，mysql8已经废除此功能
解析器
这一步主要就是对语句基于SQL语法进行 词法和语法分析还有语义分析。
词法分析
这段SQL会被打散为多个符号，每个符号的类型，起始的位置。
语法分析
检查关键语法的是否符合MySQL语法进行语法解析，判断输入的这个 SQL 语句是否满足 MySQL 语法。然后生成下面这样一颗语法树
预处理器
检查列名、表名是否存在，保证没有歧义
优化器
当上述步骤完成，则sql语句认为是合法并且是可执行的，并且可以有很多的执行方式，并且返回相同的结果，优化器会把一条sql语句转化成执行计划，并且找到其中
最好的执行计划！
MySQL的优化器能处理哪些优化类型呢？
1、当我们对多张表进行关联查询的时候，以哪个表的数据作为基准表。
2、有多个索引可以使用的时候，选择哪个索引。
3、子查询优化，SQL子句顺序。
根据cost 基准器生成执行计划，那个执行计划消耗小就用那个。
生成一个执行计划之后，是要交给谁去执行？
执行器
执行器就利用存储引擎提供的，相关API来完成操作，并且把数据返回给我们客户端。
存储引擎
数据真正存储的地方，存储引擎包含了：存储方式、存储结构、检索方式

内存架构
buffer pool 怎么做到降低读写磁盘IO次数的？
数据库里只有两种操作，那我们就做在这两个方面去入手。
读
有一个重要的概念，page（页）：Buffer Pool 操作数据的最小单元。
在操作系统和存储引擎当中，都有预读的概念，当磁盘上一块数据被读取的时候，其他附近的数据也会马上被读取，这个叫做局部性原理。
写
当我们Buffer Pool里一个Page 页被更改了，那么这个数据页就是我们脏数据页对吧，那脏数据页就是跟我们的磁盘数据不一致，为了保证一直，我们需要把脏数据
页刷写到磁盘，这个动作就叫做刷脏。
刷脏怎么找到我的脏数据页进行刷脏呢？
buffer pool 里面有一个专门存储脏页的链表，叫做flush 链表。
刷脏在什么时间节点怎么进行？
每次更改内存的同事，立即同步到磁盘？但是这样严重影响我程序运行。
page-Cleaner ，可以配置异步刷脏的线程数量。
刷脏模式
空闲模式：系统空闲我就刷
脏页自适应：根据你脏页产生的速度来刷脏，innodb_max_dirty_pages_pct_lwm和
innodb_max_dirty_pages_pct
Redo 自适应：根据你Redo产生的速度还有脏页使用的比例来计算，
MySQL正常关闭
刷脏的时候，如果我刷到一半，就是刷写磁盘宕机出现数据不一致。

redo log :物理结构/逻辑日志 顺序io 记录了page页中的记录更改 (多个)
undo log :回滚日志/提供回滚 mvcc
bin log :

Buffer Pool
刷脏存在数据一致性的问题
MySQL提供了Double Write Buffer
Buffer Pool
存在数据丢失场景
然后出现了保证我们数据丢失，崩溃恢复的日志RedoLog。
参数：innodb_flush_log_at_trx_commit = 1

什么是索引？它的作用是什么？
概念
索引在关系型数据库中，是一种单独的、物理的对数据库表中的一列或者
多列值进行排序的一种存储结构，它是某个表中一列或者若干列值的集合，还
有指向表中物理标识这些值的数据页的逻辑指针清单。
索引的作用相当于图书的目录，可以根据目录重点页码快速找到所需要的
内容，数据库使用索引以找到特定值，然后顺着指针找到包含该值的行，这样
可以是对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

索引能够提高数据检索的效率，降低数据库的IO成本。空间换时间

Page里面的每一条都有关键的属性叫做record_type
record_type 0 普通用户记录 1 目录的索引记录 2 最小 3 最大

索引是不是越多越好？
空间上：用空间换时间，索引是需要占用磁盘空间的。
时间上：命中索引，加快我们的查询效率，如果是更新删除，会导致页的分裂与合并，影响插入和更新语句的响应时间，延缓性能。
如果是频繁需要更新的列，不建议建立索引，因为频繁触发页的分裂与合并。
为什么离散度低的列不走索引？
离散度是什么概念，相同的数据越多离散度越低，相同的数据越少离散度就越
高。
请问都是相同的数据 怎么排序，没办法排序啊？
在B+Tree 里面重复值太多，MySQL的优化器发现走索引跟使用全表扫描差不了
多少的时候，就算建立了索引也不会走。走不走索引，是MySQL的优化器去决定
的。
二级索引树的总结
也叫作组合索引（复合索引），二级索引树存储的是我们创建索引时候的i保存
了列名顺序来存储的，它只保存了创建二级索引列名的部分数据，二级索引树是为了
辅助我们查询，提高查询效率诞生的，二级索引树里有三个动作：回表、覆盖索引、
索引下推。其中，性能最高的是覆盖索引。

区别 主键索引 二级索引
数量
 一张表只有一个主键索引树
一张表可以有多个二级索引树
存储
可以存储表里的所有列数据
存储表里的部分数据列、辅助查询，提升查询效率
创建
建表时候自动创建
手动创建
排序
主键ID、非空唯一索引、rowid
根据用户创建二级索引时候的列名从左到右
场景
主键索引，排序
回表、覆盖索引、索引下推


分库分表
垂直分库：因为数据还在一台服务器上，所以还会竞争同一台物理机的CPU、内存、
网络IO、磁盘。所以可以把不同的数据分库之后放到不同的服务器上；
按照业务将表进行分类，分布到不同的数据库上，每个库放到不同的服务器上，专表
转库，专库专用；
水平分库：水平分库是把同一张表的数据按照一定的规则拆分到不同的数据库中，每
个库可以放到不同的数据库中
垂直分表：常用的字段归为一个表中，不常用的字段归结到一个字段中；（将表的字
段按照使用频率分别存储）；
水平分表：在同一个数据库内，把同一个表的数据按照一定的规则拆到多个表中；
一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表的方
案，在数据量及访问压力不是特别大的情况，首先我们要考虑缓存、读写分离、索引
等技术方案。如果数据量极大，且持续增长，再考虑水平分库、水平分表的方案。
几种常用的分库分表策略：
HASH取模
假设有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当
uid=1时,对应到的是user1,uid=2时,对应的是user2.
范围分片、分段分表
从1-10000一个表,10001-20000一个表。
地区位置分片
华南区一个表,华北一个表。
时间戳分片
按月分片，按季度分片等等,可以做到冷热数据。
分库分表带来的问题
分库分表能有效的缓解单机和单库带来的性能瓶颈和压力，突破网络IO、硬件
资源、连接数的瓶颈，同时也会带来一些问题；
事务一致性的问题
由于分库分表把数据分布到了不同库甚至不同的服务器上，不可避免的会带来
分布式事务问题。
跨节点关联查询比如：Join
关联查询不在一个数据库的话，我们可能要分多次查询；
跨节点分页、排序函数：比如 count 、order by，group by 以及聚合函数
数据迁移，容量规划，横向扩容等问题
主键避重
在分库分表环境中，由于表中的数据同时存在不同的数据库中，主键值平时使
用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单
独设计全局主键，以避免跨库主键重复的问题；
公共表
不同的数据库需要相同的数据，这种情况，在实际的应用场景中，参数表、数
据字典表等数据量都是数据量比较小的，变动也会比较少，而且属于高频联合查询的
依赖表。
可以将这类表在每一个数据库都保存一份，对所有的公共表的更新都同时发送
所有的分库执行。


开启之后就需要两阶段提交？
我们讲了2个log了，一个redo，一个binlog,一个是InnoDB存储引擎的，一个是
server端的日志文件；这2个日志不是1个地方操作的，那么就不是原子性的；就会产
生数据一致性问题；要么恢复的数据有问题，要么复制备份的数据会有问题。
为什么要二级阶段提交？
为了保证redo log 和binlog 数据的安全一致性，只有这个两个日志文件逻辑高
度一致 了，你才能放心使用，数据能够帮你做奔溃恢复以及主从同步等等的问题，
redo 能够帮你讲数据的状态回到崩溃之前，使用了 Binlog 实现数据备份、恢复、以
及主从同步嘛，二两阶段机制可以保证这两个日志的逻辑是高度一致的，没有错误，


Java 虚拟机就是我们java应用的运行环境，Java语言使用Java虚拟机屏蔽
操作系统和机器之间的差异，达到Write Once Run Anywhere。(一次编写到处运行)

1.2.1 Java SE Development Kit (JDK)
JDK(Java SE Development Kit)，Java标准开发包，它提供了编译、运行Java程序所
需的各种工具和资源，包括Java编译器(javac)、java运行时环境，以及常用的Java类
库等等。
1.2.2 Java Runtime Environment(JRE)
JRE(Java Runtime Environment)Java运行环境，用于解析执行Java的字节码文
件。普通用户而只需要安装JRE来运行Java程序。而程序开发者必须需要安装JDK来编
译、调试程序。
1.2.3 Java Virtual Machine (JVM)
JVM(Java Virtual Machine)，Java 虚拟机，是JRE内的一部分。它是整个Java 实
现跨平台的最核心的部分，负责解析执行字节码文件的虚拟机计算机。所有平台的
JVM向编译器提供相同的接口，而我们编译器只需要面向虚拟机，生成虚拟机能识别
的代码（字节码），然后由虚拟机来解释执行。

我需要JDK里面的工具帮我编译源代码，而且需要JRE核心类库做支持，并且
运行在JVM中测试应用程序。

javac 去编译程序源代码，转换成Java字节码，JVM通过解析字节码文件，将其翻译成对应的机器指令，逐条读入，逐条解析。

类的生命周期
加载 连接 验证 解析 初始化 使用 销毁

1. 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class
所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类
加载器来载入。
2. 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使
用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该
Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，
存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修
改才会生效的原因。
3. 双亲委派：所谓的双亲委派，则是先让父亲加载器试图加载该Class，只有在父
亲加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某
个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依
次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完
成此加载任务时，才自己去加载。

目的：为了安全，保证核心类库的安全性，防止被篡改，以及保证类的唯一
启动类 扩展类 系统类 加载器
也就是说在被动的情况下，当一个类加载器收到加载请求，他不会首先自己去加载，而是传递给自己的父亲加载器。
这样所有的类都会首先传递到最上层的Bootstrap ClassLoader，只有父亲加载器无法完成加载。
那么此时儿子加载器才会自己去尝试加载。

什么叫无法加载呢？
就是根据类的限定名，类加载器没有在自己负责的加载路径中找到该类。
这里注意，我没有用父类加载器、子类加载器这样的措辞，而是使用了父亲加载器，儿子加载器。
因为呢上图中这些箭头并不表示继承关系，而是一种逻辑关系，实际上是通过
组合的方式来实现的，这也是很多博客上没有写清楚，容易误导人的一点。

第一次被破坏
在一些情况下，双亲委派机制是可以主动破坏的，细心的同学可以发现，我自
己通过匿名内部类直接重写了java.lang.classloader的load class方法，而我们的双
亲委派机制是存在于这个方法内的。那么我们这次重写就是对原有的双亲委派机制的
逻辑破坏，所以也出现同一个限定名出现了两个不同classloader进行load的情况。

.Javac编译Java文件为Class File
词法分析器：是将源代码的字符流转变为标记（Token）集合的过程
语法分析器：检查Token集合是否符合Java语言规范，有没有语法的错误，通过校
验后得到一颗抽象的语法树。
语义分析器：检查抽象语法树是否符合Java的语义，譬如变量类型检查、数据及控
制流检查、解语法糖
代码生成器：代码生成器的结果就是生成符合Java虚拟机规范的字节码。
字节码解析阅读反编译后的字节码

类的加载机制
我们期望：一个限定名的类只会被一个类加载器加载解析并且使用，这样在程序中，
它就是唯一的，不会产生歧义。
目的：为了安全，保证核心类库的安全性，防止被篡改，以及保证类是唯一的
双亲委派模型
这个逻辑非常简单，在被动的情况，当一个类加载器收到加载请求，它自身不
会进行加载，而是传递给自己的父亲加载器。
这样所有的类都会首先传递到最上层的BootStrap ClassLoader，只有父亲加载
器无法完成加载，那么儿子加载器才会尝试自己去加载。

程序计数器
特点：1.线程独有的，2.是JVM中唯一没有OOM的内存区域
程序用来存储字节码指令地址的，由执行引擎读取下一条指令进行执行。
本地方法栈
特点：线程私有，调用native方法。
虚拟机栈
特点：线程私有、内部结构是一个个的栈帧结构。
栈帧：是用于支持虚拟机方法调用和方法执行的数据结构，它是虚拟机运行是区中虚
拟机栈的栈元素。
而栈帧中主要存在四种结构，局部变量表、操作数栈、动态连接和返回地址。
动态连接
引用地址，可以简单理解为直接引用
返回地址
一个内存地址，在方法执行的时候就需要告知否则程序计数器是无法知道下一
步要做什么的。
当出现以下两种情况，当前方法将会返回。
第一种呢就是方法正常执行完成返回，第二种就是方法执行期间遇到了异常情况返回。
方法区
存储：比如是类的签名，属性和方法
方法区存储：
如像类的签名，属性和方法。
使用“永久代”实现“方法区”的缺点：
1.可能会引起内存溢出
2.永久代本身设计就比较复杂，这种设计为了部分的代码复用可能会导致内存空间管理出现未知异常。
堆
大部分对象大部分都在堆上分配
将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存。

设置大小
-Xms20M -Xmx20M
打印分配的大小
-XX:+PrintGCDetails
默认堆大小物理电脑内存大小的 1/64 最大的内存大小：物理电脑内存大小的1/4


我们想到的是堆就预分配了一块内存！！所有的对象都在一块，当我们要进行GC的时候，会去找所有的对象是否需要回收！！
但是我们的对象大部分都是朝生夕死的，那么我们就想着，能不能把大部分新创建的对象单独放到某一个地方，减少我们GC的范围，那些少部分的非朝生夕死的对象，
或者很大的对象放到我们的另外一个地方！！这样我们就有了2个区域，old区跟young区！！比例old占三分之二，young占三分之一。
年龄：一次垃圾回收，没被回收的对象年龄加1,年龄大于15了就移到老年代。
老年代：对象大小特别大。
这样我们就能保证一般情况下只会对我们的young进行GC，那么这个GC的过程叫做young GC或者MinorGC

什么时候进老年代
1. 大对象：通过-XX:PretenureSizeThreshold参数可以设置的，目的是为了减少频
繁的youngGC，大对象比较占内存
默认值是0，意思是不管多大都是先在eden中分配内存（书本3.6.2节有介绍）
2. 年限达到15岁，默认15，可以设定，但是不能超过15，-
XX:MaxTenuringThreshold=16就会报错，无法创建JVM，这个是因为java的
对象头是4bit来保存分代年龄
肯定，老年代也是需要去进行内存清理的，那么老年代的GC叫做Major GC，Major
GC一般会伴随至少一次MinorGC。
那么full GC就是我的整个堆、元空间等全局范围的GC。

（1）内存泄漏与内存溢出的区别
内存泄漏：对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪
费。
内存溢出：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对
象导致的。
（2）young gc会有stw吗？
不管什么 GC，都会有 stop-the-world，只是发生时间的长短。
（3）major gc和full gc的区别
major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。
（4）G1与CMS的区别是什么
CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。
G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少
了垃圾碎片的产生。
（5）什么是直接内存
直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会
优于Java堆。因此出于性能的考
虑，读写频繁的场合可能会考虑使用直接内存。
（6）不可达的对象一定要被回收吗？
即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于
“
缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分法中不
可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行
fifinalize 方法。当对象没有覆盖 fifinalize 方法，或 fifinalize 方法已经被虚拟机调用
过时，虚拟机将这两种情况视为没有必要执行。
被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引
用链上的任何一个对象建立关联，否则就会被真的回收。
（7）方法区中的无用类回收
方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？
判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件
则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：
该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
加载该类的 ClassLoader 已经被回收。
该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反
射访问该类的方法。
虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不
是和对象一样不使用了就会必然被回收。

1，新生代太小，导致对象提前进入老年代，触发老年代发生Full GC；
2，老年代较大，进行Full GC时耗时较大；
优化的方法是调整NewRatio的值，调整到4，发现Full GC没有再发生，只有Young
GC在执行。这就是把对象控制在新生代就清理掉，没有进入老年代（这种做法对一
些应用是很有用的，但并不是对所有应用都要这么做）
GC的次数频繁怎么办？
打印出GC日志，到底是minorGC频繁还是majorGC频繁，结合工具看一下
（1）适当增加堆内存的空间
（2）选择垃圾收集器不合适
（3）（如果是G1）停顿时间是否太严格，或者堆存的使用率可以调成高于45%

GC为了释放很小的空间却耗费了太多的时间，其原因一般有两个：1，堆太小，2，
有死循环或大对象；

程序监控调优
java 应用程序必然是正常运行的。
减少GC 频率，减少Full GC
发现现象才去解决？比如说 CPU 飙升、内存飙升
1.打印dump文件分析堆内存
2.打印GC日志，分析日志文件

-
Xms30m -Xmx30m -XX:+HeapDumpOnOutOfMemoryError -
XX:HeapDumpPath=heap1.hprof -XX:+PrintGCDetails -Xloggc:gc.log

解决思路：
1.业务日志 没有错误
2.JVM 错误日志
hs_error_pid.log
可以通过设置以下这个参数，来指定错误日志路径
-
XX:ErrorFile=./

获取Dump文件
手动
自动
idea设置VM参数、或者运行jar包时 设置
jmap -dump:format=b,file=heap.hprof 44808
-
XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=heap.hprof

MAT
Java堆分析器，用于查找内存泄漏
Heap Dump，称为堆转储文件，是Java进程在某个时间内的快照

jconsole、jvisualvm、MAT 在分析Dump文件的时候用
GC Viewer 分析GC日志

jstat
查看性能
类加载、内存、垃圾收集情况、 JIT 实时编译的运行时数据
虚拟机统计信息监控工具，本地或者远程[1]虚拟机进程中的类加载、内存、垃
圾收集、即时编译等运行时数据

jinfo
查看参数
1.实时查看某个进程id的jvm 参数
2.查看某个进程id的所有jvm参数
3.修改我们可以 manageable 热更新的参数


设置参数的方式
1.开发工具
IDEA 、Eclipse 在run configuration 里设置VM option运行jar包， java -XX:+UseG1GC xxx.jar
2.线上环境
web容器：Tomcat， startup.sh -> catalina.sh(卡特琳娜) 里设置JVM 参数
jsp + jinfo 查看某个java进程的参数，然后再调整设置
3.真实调优
java -XX:+UseG1GC xxx.jar


2. 你了解哪些限流算法
计数器、令牌桶、漏斗算法，滑动窗口算法
3. Sentinel 的限流规则有哪些
QPS,线程数
4. Sentinel 的限流策略
快速失败，预热，排队
5. Sentinel 的限流模式
–
直接（默认）：接口达到限流条件时，开启限流
–
关联：当关联的资源达到限流条件时，开启限流，适合做应用让步。例
如为一个查询的接口添加关联流控，关联资源为一个更新的接口，当更
新的接口达到阈值时，开启查询接口的限流，为更新接口让步服务器资
源。
–
链路：当从某个接口过来的资源达到限流条件时，开启限流
6. 熔断与限流的区别
7. Sentinel 降级熔断策略有哪些
慢调用，异常比例，异常数


微服务的流行，服务和服务之间的稳定性变得越来越重要。缓存、降级和限流是保护微服务系统运行稳定性的三大利器。
缓存：提升系统访问速度和增大系统能处理的容量
降级：当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉
限流：解决服务雪崩，级联服务发生阻塞时，及时熔断，防止请求堆积消耗占用
系统的线程、IO 等资源，造成其他级联服务所在服务器的崩溃
1.2 限流算法
限流算法常用的几种实现方式有如下四种：计数器、滑动窗口、漏桶和令牌桶
限流的目的应当是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率就可以拒绝服务、等
待、降级。

1.2.1 计数器
固定窗口
思想：计数器算法是使用计数器在周期内累加访问次数，当达到设定的限流值
时，触发限流策略。下一个周期开始时，进行清零，重新计数。此算法在单机
还是分布式环境下实现都非常简单，使用 redis 的 incr 原子自增性和线程安全
即可轻松实现。
计数器算法方式限流对于周期比较长的限流，存在很大的弊端。当周期1分钟,限流次数为100,当上一周期最后一秒到
下一周期刚开始1s到区间次数已经达到100次的访问量，已远远超过服务器的负载能力

Count：记录你当前进来的请求数
Limit：阈值，在某个周期内最大的请求数
period：周期
问题：无法解决临界值问题
1.2.2 滑动窗口
Sentinel 底层实现方式
思想：固定窗口存在临界值问题，要解决这种临界值问题，显然只用一个窗口
是解决不了问题的。假设我们仍然设定 1 分钟内允许通过的请求是 100 个，
但是在这里我们需要把 1 分钟的时间分成多格，假设分成 5 格（格数越多，
流量过渡越平滑），每格窗口的时间大小是 12 秒，每过 12 秒，就将窗口向
前移动一格。
阈值：limitCount
period（窗口的大小）
窗口数
passCount：记录当前的请求数
窗口当前的请求数
Hystrix和Sentinel底层都是用的该算法

1.2.3 漏桶算法
• 思想：漏桶算法是首先想象有一个木桶，桶的容量是固定的。当有请求到来时
先放到木桶中，处理请求的 worker 以固定的速度从木桶中取出请求进行相应。
如果木桶已经满了，直接返回请求频率超限的错误码或者页面

适用场景：漏桶算法是流量最均匀的限流实现方式，一般用于流量“整形”。例
如保护数据库的限流，先把对数据库的访问加入到木桶中，worker 再以 db
能够承受的 qps 从木桶中取出请求，去访问数据库。
• 问题：木桶流入请求的速率是不固定的，但是流出的速率是恒定的。这样的话
能保护系统资源不被打满，但是面对突发流量时会有大量请求失败，不适合电
商抢购和微博出现热点事件等场景的限流。'


1.2.4 令牌桶算法
• 思想：令牌桶是反向的"漏桶"，它是以恒定的速度往木桶里加入令牌，木桶满
了则不再加入令牌。服务收到请求时尝试从木桶中取出一个令牌，如果能够得
到令牌则继续执行后续的业务逻辑。如果没有得到令牌，直接返回访问频率超
限的错误码或页面等，不继续执行后续的业务

适用场景：适合电商抢购或者微博出现热点事件这种场景，因为在限流的同时
可以应对一定的突发流量。如果采用漏桶那样的均匀速度处理请求的算法，在
发生热点时间的时候，会造成大量的用户无法访问，对用户体验的损害比较大


Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制
组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来
帮助用户保护服务的稳定性。

限流模式：QPS(查询率 服务器性能标准)
QPS数还是线程数
QPS数的阈值


Seata 是阿里巴巴退出的一款用来解决分布式事务问题的框架，他经过天猫双十一
的考验，很有可能成为解决分布式事务问题的主流框架

4）Seata 分布式事务框架实现原理
Seata 有三个组成部分：事务协调器 TC：协调者、事务管理器 TM：发起方、资源
管理器 RM：参与方
• 发起方会向协调者申请一个全局事务 id，并保存到 ThreadLocal 中（为什么要
保存到 ThreadLocal 中？弱引用，线程之间不会发生数据冲突）
• Seata 数据源代理发起方和参与方的数据源，将前置镜像和后置镜像写入到
undo_log 表中，方便后期回滚使用
• 发起方获取全局事务 id，通过改写 Feign 客户端请求头传入全局事务 id。 • 参与方从请求头中获取全局事务 id 保存到 ThreadLocal 中，并把该分支注册
到 SeataServer 中。
• 如果没有出现异常，发起方会通知协调者，协调者通知所有分支，通过全局事
务 id 和本地事务 id 删除 undo_log 数据，如果出现异常，通过 undo_log 逆向
生成 sql 语句并执行，然后删除 undo_log 语句。如果处理业务逻辑代码超时，
也会回滚

SpringBoot 如何整合 Seata
• 第一步：引入依赖
• 第二步：bin 下的 file 文件和 registry 文件放入到每个项目中，并修改，分组
名称要保持一致
• 第三步：yml 配置 seata
• 第四步：引入 DataSourceProxy 配置文件

全局事务提交流程
因为每个分支事务的本地事务都已经被提交，所以如果全局事务能够顺利进行到
“提交“这一阶段，那么意味着所有事务分支的本地事 务都已经被提交了，数据的一
致性已经得到了保证。
这个时候全局事务的提交就变得十分轻量级，就是把 undo_log 对应的记录删掉即
可，即使是当时删除失败了，也已经不会影响全局事 务的最终结果，这次删不了，
那就待会再删，程序删不了，没事，顶多人工删。

全局事务回滚流程
如果全局事务的任何一个事务分支失败了，那么全局事务就进入“回滚“流程，回滚
时依据先前保存好数据镜像，将原来的数据回放回去。
如果全局回放成功，那么数据的一致性也就得到了保证，如果回放不成功，那么
事务就进入异常。应对异常，可能需要重试，可能需要人工介入。

1.1 CAP 理论
• C：consistency（强一致性）：所有的节点上的数据时刻保持同步
• A：Avaliablity（可用性）：每个请求都能接受到一个响应，无论响应成功或
失败
• P：Partition Tolerance（分区容错）：系统应该能持续提供服务，即使系统内
部有消息丢失（分

组成模块
Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式
事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一
站式的分布式解决方案


什么是服务熔断
熔断很好理解，就是一个断开的过程；
在微服务里面也是一样，当下游的服务因为某种原因突然变得不可用或响应过慢，
上游服务为了保证自己整体服务的可用性，不再继续调用目标服务，直接返回，快速释放资源。
如果目标服务情况好转则恢复调用

熔断和降级的关系
说了那么多，其实也能想到了，降级和熔断其实就是服务安全中的2个不同的流程，在服务发生故障时，
肯定是先断开（熔断）与服务的连接，然后在执行降级逻辑；
降级是一种设计思想，在java层面就是一个接口，而熔断是降级的不同实现方式

1、熔断降级（不可用）
熔断逻辑是这样的，A服务调用B服务，失败次数达到一定阈值后 ，A服务的断路器打开，
就不在请求B服务，而是直接执行本地的fallback方法；这种叫做熔断降级，看到这里，
也许你已经明白了，熔断只是降级的其中一种实现方式；

2、超时降级
同样是A服务调用B服务，B服务响应超过了A服务设定的阈值后，就会执行降级逻辑；

3、限流降级
同样是A服务调用B服务，服务A的连接已超过自身能承载的最大连接数，比如说A能承载的连接数为5，但
是目前的并发有6个请求同时进行，前5请求能正常请求，最后一个会直接拒绝，执行fallback降级逻辑；


关系型数据库 单节点 保证了数据强一致性（C）和可用性（A），但是却无法保证分区容错性（P）。

然而在分布式系统下，为了保证模块的分区容错性（P），只能在数据强一致性（C）和可用性（A）之间做平衡。具体表现为在一定时间内，可能模块之间数据是不一致的，但是通过自动或手动补偿后能够达到最终的一致。

BASE 理论主要是解决 CAP 理论中分布式系统的可用性和一致性不可兼得的问题。BASE 理论包含以下三个要素：



BA：Basically Available，基本可用。

S：Soft State，软状态，状态可以有一段时间不同步。

E：Eventually Consistent，最终一致，最终数据是一致的就可以了，而不是时时保持强一致。



BASE 模型与 ACID 不同，满足 CAP 理论，通过 牺牲强一致性来保证系统可用性。由于牺牲了强一致性，系统在处理请求的过程中，数据可以存在短时的不一致。

系统在处理业务时，记录每一步的临时状态。当出现异常时，根据状态判断是否继续处理请求或者退回原始状态，从而达到数据的最终一致。

例如，在上面的案例中，支付成功，订单也成功，但增加积分失败，此时，不应回滚支付和订单，而应通过一些 补偿方法 来让积分得以正确地增加。后面会讲到具体的实现方法。



netty 异步NIO的驱动
是一个异步的、基于事件驱动的网络应用框架，用以开发高性能、高可用的网络io程序
Netty应用的场景
作为基础的通信组件被RPC框架使用，例如dubbo
游戏行业
大数据领域：AVRO实现数据文件的共享


什么是Nginx

Nginx 是款性能的 http 服务器/反向代理服务器及电邮件（IMAP/POP3）代理服务器。
官测试 nginx 能够撑 5 万并发链接，并且cpu、内存等资源消耗却常低，运常稳定。
Nginx应场景：

1、http 服务器。 Nginx 是个 http 服务可以独提供 http 服务。可以做静态服务器。

2、虚拟主机。 可以实现在台服务器虚拟出多个站。例如个站使的虚拟主机。

3、反向代理，负载均衡。 当站的访问量达到定程度后，单台服务器不能满户的请求时，需要多台服务器集群可以使 nginx 做反向代理。
并且多台服务器可以平均分担负载，不会因为某台服务器负载宕机某台服务器闲置的情况。
Nginx的正向代理：代理的是客户端。

Nginx的反向代理：代理的是服务端。在web服务中，一般都是反向代理，用一个nginx代理服务的统一入口。

将静态资源和动态资源放在不同的URL


三大核心部分：Channel(管道) ，Buffer(缓冲区)，Selector(选择器)



一、Java垃圾回收器要负责完成以下3个任务：
1、分配内存

2、确保被引用对象的内存不被错误回收

3、回收不再被引用的对象的内存空间

二、垃圾回收是一个复杂而又耗时的操作
如果JVM花费过多的时间在垃圾回收上，则势必会影响应用的运行性能。一般情况下，垃圾回收器在运行操作的时候，整个应用的执行时被暂时中止的。这是因为垃圾回收器需要重新更新应用中所有对象引用的实际内存地址。

三、垃圾回收方式
      不同硬件平台能支持的垃圾回收方式也是不同。比如多cpu的平台上，就可以通过并行的方式进行垃圾回收，而单cpu平台只能串行进行。不同应用期望的垃圾回收方式也不同。服务器端应用可能希望在整个应用的运行时间中，花在垃圾回收上是时间总数越小越好。对于与用户交互的应用来说，则可能希望垃圾回收带来的停顿的时间间隔越小越好。对于这种情况JVM提供了多种垃圾回收的方法以及对应的性能调优参数，应用可以根据需求定制。

     目前JVM都采用分代收集，在分代收集的基础上又分为串行收集、并行收集以及并发收集。

串行垃圾回收器(Serial Garbage Collector)

并行垃圾回收器(Parallel Garbage Collector)

并发标记扫描垃圾回收器(CMS Garbage Collector)

G1垃圾回收器(G1 Garbage Collector)


1、串行垃圾回收器

串行垃圾回收器通过持有应用程序所有的线程进行工作。它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有应用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序。

通过JVM参数-XX:+UseSerialGC可以使用串行垃圾回收器。

2、并行垃圾回收器

并行垃圾回收器也叫做 throughput collector 。它是JVM的默认垃圾回收器。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，它也会冻结所有的应用程序线程当执行垃圾回收的时候

3、并发标记扫描垃圾回收器

并发标记垃圾回收使用多线程扫描堆内存，标记需要清理的实例并且清理被标记过的实例。并发标记垃圾回收器只会在下面两种情况持有应用程序所有线程。

当标记的引用对象在tenured区域；

在进行垃圾回收的时候，堆内存的数据被并发的改变。

相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择相比并发垃圾回收器。

通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。

4、G1垃圾回收器

G1垃圾回收器适用于堆内存很大的情况，他将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。G1也可以在回收内存之后对剩余的堆内存空间进行压缩。并发扫描标记垃圾回收器在STW情况下压缩内存。G1垃圾回收会优先选择第一块垃圾最多的区域

通过JVM参数 –XX:+UseG1GC 使用G1垃圾回收器
配置描述

-Xms

初始化堆内存大小

-Xmx

堆内存最大值

-Xmn

新生代大小

-XX:PermSize

初始化永久代大小

-XX:MaxPermSize

永久代最大容量

使用JVM GC参数的例子

java -Xmx12m -Xms3m -Xmn1m -XX:PermSize=20m -XX:MaxPermSize=20m -XX:+UseSerialGC -jar java-application.jar
1、串行收集器

串行收集器的工作过程用单线程处理所有垃圾回收工作，因为没有多线程交互，所以效率比较高。但是不适合多处理器，一般适合在单处理器上使用。

2、并行收集器

并行处理器是多线程处理垃圾回收工作，可以减少垃圾回收的时间，一般在多线程多处理器上使用。 并行垃圾回收的线程数和机器的处理器数相等。

此收集器可以进行如下配置：

（1）最大垃圾回收暂停：指定垃圾回收的最长暂停时间。如果指定了此值，则会调整堆大小和垃圾回收相关参数，已达到此值。此值的设置可能会减少应用的吞吐量

（2）吞吐量：吞吐量是垃圾回收的时间与非垃圾回收的时间的比值。

3、并发收集器。

并发收集器可以保证大部分工作都并发进行（应用不暂停），垃圾回收只暂停很少时间。并发收集器主要减少年老代的暂停时间，它在应用不暂停的情况下，使用独立的垃圾回收线程，跟踪可达对象。



SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架
Spring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架,本质上相当于 Servlet。 Spring MVC 是结构最清晰的 Servlet+JSP+JavaBean 的实现,


Spring框架的有哪些优点？
方便解耦，简化开发：将所有对象的创建和依赖关系维护交给Spring管理。
方便集成各种优秀框架：Spring内部提供了对各种优秀框架（Struts2、Hibernate、MyBatis）的直接支持。
降低了Java EE API使用难度：对JAVA EE开发中一些API（JDBC、JavaMail、远程调用）都提供了封装。
方便程序测试：支持JUnit4,可以通过注解方便地测试Spring程序。
AOP变成支持：面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。
声明式事务：通过配置就可以完成对事务的管理，无需编程。

非侵入式设计
Spring是一种非侵入式（non-invasive）框架，它可以使应用程序代码对框架的依赖最小化。
● 方便解耦、简化开发
Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护工作都交给Spring容器管理，大大的降低了组件之间的耦合性。
● 支持AOP
Spring提供了对AOP的支持，它允许将一些通用任务，如安全、事务、日志等进行集中式处理，从而提高了程序的复用性
● 支持声明式事务处
只需要通过配置就可以完成对事务的管理，而无需手动编程。
● 方便程序的测试
Spring提供了对Junit4的支持，可以通过注解方便的测试Spring程序。
● 方便集成各种优秀框架
Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持。
● 降低Java EE API的使用难度
Spring对Java EE开发中非常难用的一些API（如：JDBC、JavaMail等），都提供了封装，使这些API应用难度大大降低。
Spring framework
即Spring,是其他Spring全家桶的基础和核心：包括SpringMVC、SpringBoot、SpringCloud、SpringData、SpringSecurity。

Spring中三种配置Bean的方式
1.使用xml配置文件
2.使用Java注解的配置
3.使用Java类的配置

Bean的生命周期
Bean的生命周期包括四个阶段：实例化Instantiation 、属性赋值Populate 、初始化Initalization 、销毁Destruction

1、实例化 Instantiation

对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一尚未初始化的依赖时，容器会调用createBean进行实例化。

对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。

2、设置对象属性（依赖注入）

实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition中的信息以及通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。

3、处理Aware接口

Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，可以让我们拿到Spring容器的一些资源：

① 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName（String beanid）方法，传入Bean的名字；

② 如果这个Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader（）方法，传入ClassLoader对象的实例。

③ 如果这个Bean实现了BeanFactoryAware接口，会调用它是实现的setBeanFactory（）方法，传递的是Spring工厂自身。

④ 如果这个Bean实现了ApplicationContextAware接口，会调用 setApplicationContext（ApplicationContext）方法，传入Spring上下文；

4、BeanPostProcessor前置处理

如果想对Bean进行一些自定义的前置处理，那么可以让Bean实现了BeanPostProcessor接口，那么将会调用postProcessBeforeInitializ（Object obj，String s）方法。

5、InitialzingBean

如果Bean实现了InitialzingBean接口，执行afterPropertiesSet()方法。

6、init-method

如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法。

7、BeanPostProcessor后置处理

以上几个步骤完成后，Bean已经正确创建。

如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitiazation（Object obj，String s）方法，由于这个方法是在Bean初始化结束时调用，所以可以被应用于内存或缓存技术；

8、DisposableBean

当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy（）方法；

9、destory-method

最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。


BeanFactory和ApplicationContext是Spring的两大核心接口，都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。

BeanFactory:

BeanFactory是Spring里面最底层的接口,是Ioc的核心,定义了Ioc的基本功能,包含了各种Bean的定义、加载、实例化,依赖注入和生命周期管理;

ApplicationContext

ApplicationContext接口作为BeanFactory的子类,除了提供BeanFactory所具有的功能外,还提供了更完整的框架功能:
①继承MessageSource,因此支持国际化
②资源文件访问，如URL和文件（ResourceLoader）
③载入多个（有继承关系）上下文（及同时加载多个配置文件），使得每一个上下文都专注于一个特定的层次
④提供在监听器中注册bean的事件；
在实际开发中，通常都选择使用 ApplicationContext，而只有在系统资源较少时，才考虑使用 BeanFactory。
相同：

Application其实就是通过继承ListableBeanFactory, HierarchicalBeanFactory间接继承了Beanfatory，所以拥有Beanfactory的全部功能（可以生成、维护BEAN）；

不同点：

但是他还继承了诸如EnvironmentCapable, MessageSource, ApplicationEventPublisher, ResourcePatternResolver，从而ApplicationContext还可以获取系统环境变量、国际化、事件发布等功能，这是Beanfactory不具备的。


BeanFactory与FactoryBean的区别

1）BeanFactory 是接口，提供了IOC容器最基本的形式，给具体的IOC容器的实现提供了规范，顶层接口。

2）FactoryBean 也是接口，为IOC容器中Bean的实现提供了更加灵活的方式，FactoryBean在IOC容器的基础上给Bean的实现加上了一个简单的工厂模式和装饰模式 ，我们可以在getObject()方法中灵活配置.

区别：FactoryBean是个Bean.在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 .


Spring本身并没有针对Bean做线程安全的处理，所以:
1.如果Bean是无状态的，那么Bean则是线程安全的
2.如果Bean是有状态的，那么Bean则不是线程安全的

另外，Bean是不是线程安全，跟Bean的作用域没有关系，Bean的作用域只是表示Bean的生命周期范围，对于任何生命周期的Bean都是一个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。

无状态：表示这个实例没有属性对象，不能保存实数据，是不变的类。比如：controller、service、dao。
有状态：表示实例是有属性的对象，可以保存数据，是线程不安全的，比如：pojo。

这个问题主要是针对Spring中的bean的线程安全问题。
Spring中的Bean默认是单例的，单例的是被所有线程共享的，所以会存在安全问题，如果想要线程安全，可
以设置为多例的Bean。
追问：那么为什么有些bean是单例的呢，却又是安全的？
因为一般来说线程不安全是说共享的资源不安全，但是有些bean其实没又资源的概念，比如dao接口，只有
像实体类，我们一般设置为多例的，因为里面包含了数据资源。

什么是 spring 的内部 bean？
只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。
为了定义 bean，Spring 的基于 XML 的配置元数据在 <property> 或
<constructor-arg> 中提供了 <bean> 元素的使用。内部 bean 总是匿名
的，它们总是作为原型

spring bean 的作用域之间有什么区别？
spring容器中的bean可以分为五个范围。
1.singleton:这种bean范围是默认的，这种范围确保不管接受到多个请求，每个容器中有一个bean的实例，单利模式由bean factory自身来维护。
2.Protype:原先通过范围与单例范围相反，为每一个bean请求提供一个实例。
3.request：在请求bean范围内会每一个来自客户端的网络请求创建一个实例，在请求完成之后，bean会失效并被垃圾回收器回收。
4.session：与请求范围类似，确保每个session中的bean的实例在session过期后bean会随之消失。
5.global-session:global-session和portlet公用全局存储变量的话，那么这全局变量需要存储在global-session中。

springmvc中controller不要定义全局变量
因为controller是默认单例模式，高并发下全局变量会出现线程安全问题
现这种问题如何解决呢？
第一种方式： 既然是全局变量惹的祸，那就将全局变量都编程局部变量，通过方法参数来传递。
第二种方式： jdk提供了java.lang.ThreadLocal,它为多线程并发提供了新思路。
第三种：使用@Scope(“session”)，会话级别
springmvc并发调用controller方法时对局部变量的影响
1 对于一个requestMapping局部变量，每个线程在调用时都会copy一份，然后使用，因此并不会影响其他的调用
2 对于全局变量/成员变量则不会，会产生多线程问题，常见的解决方式是加锁。

Spring 注入集合
我们还可以在 Bean 标签下的 <property> 元素中，使用以下元素配置 Java 集合类型的属性和参数，例如 List、Set、Map 以及 Properties 等。
标签	    说明
<list>	用于注入 list 类型的值，允许重复
<set>	用于注入 set 类型的值，不允许重复
<map>	用于注入 key-value 的集合，其中 key 和 value 都可以是任意类型
<props>	用于注入 key-value 的集合，其中 key  和 value 都是字符串类型
什么是Spring MVC框架的控制器？
控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。
Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。


spring DAO 有什么用？
Spring 对持久层技术的支持 对JDBC，Hibernate 或JPA,iBatis 这样的数据访问技术更容易以一种统一的方式工作。
这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。

spring JDBC API 中存在哪些类？
JdbcTemplate
SimpleJdbcTemplate
NamedParameterJdbcTemplate
SimpleJdbcInsert
SimpleJdbcCall

Spring框架中有哪些不同类型的事件 原创
Spring 提供了以下5种标准的事件：
（1）上下文更新事件（ContextRefreshedEvent）：在调用ConfigurableApplicationContext 接口中的refresh()方法时被触发。
（2）上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext的Start()方法开始/重新开始容器时触发该事件。
（3）上下文停止事件（ContextStoppedEvent）：当容器调用ConfigurableApplicationContext的Stop()方法停止容器时触发该事件。
（4）上下文关闭事件（ContextClosedEvent）：当ApplicationContext被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。
（5）请求处理事件（RequestHandledEvent）：在Web应用中，当一个http请求（request）结束触发该事件。
如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent 被发布以后，bean会自动被通知。

如果一个bean实现了ApplicationListener接口，当一个ApplicationEvent被发布后，遍历所有监听器，对于每一个监听器来说其实都可以获取到监听事件，但是是否进行处理则由事件监听器来决定，如果要处理，使用onApplicationEvent()方法来进行监听器的处理 　　自定义监听事件，需要ApplicationEvent接口，ApplicationContext使用publishEvent()方法来发布事件。

Spring 提供了两种方式
实现 ApplicationListener 接口
使用注解 @EventListener

spring自动装配是什么？spring自动装配方式
1. byName
从Spring环境中获取目标对象时，目标对象中的属性会根据名称在整个Spring环境中查找标签的id属性值。如果有相同的，那么获取这个对象，实现关联。
整个Spring环境：表示所有的spring配置文件中查找，那么id不能有重复的。
2. byType
从Spring环境中获取目标对象时，目标对象中的属性会根据类型在整个spring环境中查找标签的class属性值。如果有相同的，那么获取这个对象，实现关联。
缺点：如果存在多个相同类型的bean对象，会出错。
如果属性为单一类型的数据，那么查找到多个关联对象会发生错误。
如果属性为数组或集合(泛型)类型，那么查找到多个关联对象不会发生异常。
3. constructor
使用构造方法完成对象注入，其实也是根据构造方法的参数类型进行对象查找，相当于采用byType的方式。
4. autodetect
自动选择：如果对象没有无参数的构造方法，那么自动选择constructor的自动装配方式进行构造注入。如果对象含有无参数的构造方法，那么自动选择byType的自动装配方式进行setter注入。
5. no
不支持自动装配功能。

.1、什么是自动装配
自动装配，是指：Spring自动的建立Bean对象和Bean对象之间的依赖关系，而不需要我们开发人员手动的进行设置，这个过程就叫做自动装配。

自动装配，其实就是和之前介绍的依赖注入是一样的，只不过我们进行依赖注入的时候，需要开发人员在XML配置文件里面，通过【<property>】标签或者【<constructor-arg>】标签，手动的进行属性赋值，可以想到，如果项目中有很多对象都需要赋值，那这样就需要编写许多的XML配置代码，这不利于XML配置文件的维护。为了能够简化一下依赖注入，所以就提出了自动装配的概念，目的就是让Spring自动的替我们给属性赋值，从而简化XML配置。

Spring中默认情况下，是没有开启自动装配的功能，如果我们需要使用自动装配，则需要通过在【<bean>】标签中添加【autowire】属性，然后设置采用哪种自动装配的方式，Spring提供了五种自动装配的方式，分别是：

no：表示不自动装配。

default：表示按照【<beans>】根标签上面配置的【default-autowire】方式进行自动装配。

byType：表示根据Bean的数据类型进行自动装配。（如果存在多个相同数据类型的Bean，则自动装配失败，抛出异常。）

byName：表示根据Bean的名称进行自动装配。（根据bean的id属性值进行属性，如果存在多个相同名称的id属性值，则抛出异常。）

constructor：表示通过构造方法进行自动装配。（根据Bean的构造方法进行自动装配，根据构造方法参数的数据类型进行属性赋值。

1.4、SpringMVC执行原理（精简总结）
用户发起请求，DispatcherServlet接受用户的请求。
DispatcherServlet接受用户的请求以后，调用HandlerMapping处理器映射器，处理器映射器根据url查找相应的控制器，找到以后通过HandlerExecution将相应的解析结构返还给DispatchServlet。
DispatchServlet根据相应的解析后控制器去找处理器适配器，然后处理器适配器按照特定的规则调用Controller（Controller层就是调用相应的业务层的东西了），然后Controller将相应的结果返回给处理器适配器，如模型和视图，然后处理器适配器将结果返回给DispatchServlet。
DispatcherServlet调用视图解析器来解析处理器适配器传回来的东西，然后视图解析器将解析后的结果传回给DispatcherServlet。
DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，最终视图呈现给用户。
1.5、总结
SpringMVC的三大核心：处理器映射器（HandlerMapping）、处理器适配器（HandlerAdapter）、视图解析器（ViewResolver）；而DispatcherServlet负责三个模块之间的通信！


ApplicationContext
实用的Bean工厂ApplicationContext
ApplicationContext的中文意思是“应用前后关系”，它继承自BeanFactory接口，除了包含BeanFactory的所有功能之外，在国际化支持、资源访问（如URL和文件）、事件传播等方面进行了良好的支持，被推荐为Java EE应用之首选，可应用在Java APP与Java Web中。


Springmvc中拦截器与过滤器的区别
1.过滤器是servlet中的对象，拦截器是框架中的对象
2.过滤器实现Filter接口对象，拦截器是实现HandleInterceptor
3.过滤器是用来设置request，response参数、属性，侧重对数据的过滤；拦截器是用来验证请求的，能截断请求。
4.过滤器是在拦截器之前执行的
5.过滤器是tomcat服务器创建的对象，拦截器是springmvc容器创建的对象
6.过滤器是一个执行时间点；拦截器是三个执行时间点
7.过滤器可以处理jsp、js、html等；拦截器是侧重拦截Controller的对象，如果你的请求不能被DispatcherServlet接收，这个请求不会执行拦截器的内容
8.拦截器拦截普通类方法执行，过滤器过滤servlet请求响应
4 过滤器和拦截器的区别
过滤器和拦截器均体现了AOP的编程思想，都可以实现诸如日志，登录鉴权等功能，但二者的不同点也是比较多的
拦截器是基于Java的反射机制，而过滤器是基于函数回调
拦截器不依赖与Servlet容器，而过滤器依赖Servlet容器
拦截器只能对Controller请求起作用，而过滤器可以对几乎所有请求起作用
拦截器可以访问Controller上下文，值栈里的对象，而过滤器不能
在Spring容器的生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次

Spring加载流程
 tomcat在启动ServletContext容器的时候会发布ServletContextEvent事件，
 Spring就通过实现ServletContextListener接口，监听该事件来监听ServletContext的生命周期。
 web.xml中配置了ContextLoaderListener实现了ServletContextListener接口。
 对ServletContext启动监听，在initWebApplicationContext方法中会通过ServletContext获取web.xml中配置的contextConfigLocation参数值，
 也就是spring的xml配置然后会调用SpringIOC容器refresh()方法初始化容器：
refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，
容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，
我们把它们称为 refresh 的 12 个步骤：


Spring通知有哪些类型？Spring通知有哪些类型？
（1）前置通知（Before advice）：在某连接点（join point）之前执⾏的通知，但这个通知不能阻⽌连接点前的执⾏（除⾮它抛出⼀个异常）。
（2）返回后通知（After returning advice）：在某连接点（join point）正常完成后执⾏的通知：例如，⼀个⽅法没有抛出任何异常，正常返回。
（3）抛出异常后通知（After throwing advice）：在⽅法抛出异常退出时执⾏的通知。
（4）后通知（After (finally) advice）：当某连接点退出的时候执⾏的通知（不论是正常返回还是异常退出）。
（5）环绕通知（Around Advice）：包围⼀个连接点（join point）的通知，如⽅法调⽤。这是最强⼤的⼀种通知类型。 环绕通知可以在⽅法调⽤前后完成⾃定义的⾏为。
它也会选择是否继续执⾏连接点或直接返回它们⾃⼰的返回值或抛出异常来结束执⾏。 环绕通知是最常⽤的⼀种通知类型。⼤部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。


Spring AOP中常用名词解释
1.切面（Aspect）：
一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现。

2.连接点（Joinpoint）：
在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。

3.通知（Advice）：
在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。

4.切入点（Pointcut）：
匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。 切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。

5.引入（Introduction）：
（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。

6.目标对象（Target Object）：
被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。

7.AOP代理（AOP Proxy）：
AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。

8.织入（Weaving）：
把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。


1.2 关注点和横切关注点的区别
关注点是我们想在应用的模块中实现的行为。
关注点可以被定义为：想实现以解决特定业务问题的方法。比如，在所有电子商务应用中，不同的关注点（或者模块）可能是库存管理、航运管理、用户管理等。
横切关注点是贯穿整个应用程序的关注点。像日志、安全和数据转换，它们在应用的每一个模块都是必须的，所以他们是一种横切关注点。
 关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。
 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些
 都属于横切关注点。


 Spring框架的事务管理有哪些优点？
 它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。
 它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如
 它支持声明式事务管理。
 它和Spring各种数据访问抽象层很好得集成。
 大多数Spring框架的用户选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。声明式事务管理要优于编程式事务管理，虽然比编程式事务管理（这种方式允许你通过代码控制事务）少了一点灵活性。

spring什么时候实例化bean
第一：如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时候实例化
第二：如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况：
（1）：如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取
（2）：如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化
（3）：如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化



上一份工作的晋升渠道不明确，随着个人能力的提升，职位和薪资都没有明显的提升，不利于个人规划。
个人原因可以包括老家临时有事，突然中断工作；

AT：基于本地事务和二阶段提交协议来实现的最终一致性方案
XA：一种强一致性的事务解决方法
SAGA：提供长事务连接的解决方案
TCC；Try,Confirm,Cancel将一个完整的业务拆分三个阶段,通过事务管理器在业务逻辑实现情况分别调用Confirm,Cancel


约定大于配置
是一种软件开放规范,减少对配置项维护,聚焦到业务逻辑上,更高效对实现开发维护
SpringBootStarter启动依赖，帮我们管理jar包版本

jstack获取dump日志


spho.entity


CyclicBarrier和CountDownLatch其实非常相似，CyclicBarrier表示加法，CountDownLatch表示减法。
CyclicBarrier只能够唤醒一个任务，CountDownLatch可以唤起多个任务。
CyclicBarrier可以重置，重新使用，但是CountDownLatch的值等于0时，就不可重复用了。


mybatis
Executor:执行语句
StatementHandler:处理sql语句预编译,设置参数等相关工作
ParameterHandler:设置预编译参数用的
ResultSetHandler:处理结果集
TypeHandler:整个过程中,进行数据库类型和javaBean类型映射

Mybatis的整体流程能简单讲下吗？
初始化工作 1.解析配置文件，得到sqlSessionFactory,把配置文件中的参数都保存到conퟕ�guration类中
2.解析mapper.xml文件，把每一个语句封装成一个MappedStatement，并且放入到Map； key:namespace+sqlid value:MappedStatement
3.为每一个mapper接口类都会封装一个MapperProxyFactory与namespace映射关系保存到map中 会话创建
创建会话去执行sql，肯定离不开SqlSession，我们先介绍下什么是SqlSession,就像在Navicat中打开的 一个窗口，
多个窗口就是多个sqlSession 1. 创建事务 2. 创建执行器，分别有三种执行器 3. 返回DefaultSqlSession对象
语句执行1. 从knownMappers获取该接口的代理工厂类
2. 使用JDK动态代理创建接口的代理类,MapperProxy 为代理类，用于代理Mapper接口方法，调用 mapper接口的方法都会到代理类
MapperProxy的invoke方法
3. 获取MappedStatement，这个在初始化的时候，我们就知道存的是什么，一个sql语句标签对应一 个MappedStatement
4. 通过执行器执行语句，返回结果
为什么调用dao接口的方法就能调用sql查询数据，实现原理是什 么？在第一步build的时候就会根据mapper XML里面的nameSpace拿到接口并且创建一个
代理类工厂new MapperProxyFactory<>(type)，存入我们的knownMappers集合，此时还没有创建代理类：
入口在parse的bindMapperForNamespace(); 同时会把sql语句放入mappedStatements的一个map中
在调用session.getMapper(BlogMapper.class)方法时，会根据class创建一个代理类，并且返回代理类 执行方法时，执行的时我们代理类的方法MapperProxy，
在代理类方法中，执行我们的逻辑，并且从 MappedStatement拿到一开始就加载好的sql语句

mybatis的一级缓存和二级缓存你了解吗？能说下他们的区别 吗？一级缓存：作用域为SqlSession，存在BaseExecutor下的PerpetualCache下的cache，默认开启。存入在查 询的方法里面 二级缓存：作用域为nameSpace 二级缓存开启需要2个条件： 1.要有CachingExecutor，所以由cacheEnabled配置决定，默认是true 2.Mapper必须要有Cache标签，也就是决定currentCache有没有 3.还要sql上useCache标签为true,对于query语句默认为true,如果想关闭，可以设置为false 追问：什么时候有清除? 增删改查的标签上有属性：韈�ushCache="true"，select语句默认是false，一级二级缓存都会被清理 如果开启了事务，则最后都是在commit或者rollback后进行处理 修改和删除都会清除缓存
Mybatis中的执行器你了解吗？他们的区是什么？ simple: 普通执行器，默认， 对每条sql进行预编译->设置参数->执行等操作 reuse:执行器会重用预处理语句（PreparedStatement） batch:执行器不仅重用语句还会执行批量更新 批量执行器, 对相同sql进行一次预编译, 然后设置参数, 最后统 一执行操作
Mybatis中的xml映射文件中的sql的id是否可以重复 如果同一个nameSpace不可以,会报错 如果不是同一个nameSpace不可以
Mybatis是如何进行分页的？分页插件的原理是什么？ Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非物理分页。 可以在 sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页，分页 插件的基本原理是使用 Mybatis 提供的插件口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql， 然后重写 sq
#{}和${}的区别
{}是预编译处理，${}是字符串替换。 Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值； Mybatis 在处理时 ， 就 是 把 {}替换成变量的值。 使用#{}可以有效 的防止 SQL注入，提高系统安全性。



spring ioc
1.读取配置文件
2.扫描配置文件配置的路径，把路径中的类都变成BeanDefinition
3.把BeanDefinition封装成beanDefinitionMap；beanDefinitionMap的key=类名称，
value=BeanDefinition
4.通过for循环实例化对象，完成属性注入，并放入到容器中
1.调用getBean方法得到BeanDefinition
2.通过BeanDefinition通过反射实例化对象，放入到factoryBeanObjectCache
3.封装成GPBeanWrapper
4.属性注入：把对象中的加了GPAutowired注解的成员变量赋值
5.把对象保存到容器里面去

Bean的生命周期 实例化 属性注入 初始化 销毁

// 表示作用在类上
@Target({ElementType.TYPE})
// 运行时的注解
@Retention(RetentionPolicy.RUNTIME)
// @Documented 将此注解包含在javadoc 中
@Documented
// 代表是spring的注解，会被spring扫描到 @Component


1.2.3 Java 线程池的工作流程
Java 线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线
程队列和管理线程池的线程资源。在调用 execute()添加一个任务时，线程池会按
照以下流程执行任务。
◎ 如果正在运行的线程数量少于 corePoolSize（用户定义的核心线程数），线程池
就会立刻创建线程并执行该线程任务。
◎ 如果正在运行的线程数量大于等于 corePoolSize，该任务就将被放入阻塞队列中。
◎ 在阻塞队列已满且正在运行的线程数量少于 maximumPoolSize 时，线程池会创
建非核心线程立刻执行该线程任务。
◎ 在阻塞队列已满且正在运行的线程数量大于等于 maximumPoolSize 时，线程池
将拒绝执行该线程任务并抛出 RejectExecutionException 异常。
◎ 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中
取下一个线程任务继续执行。
◎ 在线程处于空闲状态的时间超过 keepAliveTime 时间时，正在运行的线程数量
超过 corePoolSize，该线程将会被认定为空闲线程并停止。因此在线程池中所有线
程任务都执行完毕后，线程池会收缩到 corePoolSize 大小


1. 获得同步锁；
2. 清空工作内存；
3. 从主内存拷贝对象副本到工作内存；
4. 执行代码(计算或者输出等)；
5. 刷新主内存数据；
6. 释放同步锁。
所以，synchronized 既保证了多线程的并发有序性，又保证了多线程的内存可见
性和原子性。

1.禁止编译器对代码进行某些优化
2.lock 汇编指令，锁住缓存行，启动内存屏障，禁止指令重排，保证有序性与可见
性

失效、回表、覆盖索引、索引下推
1.离散度：如果列的数据重复度高，那么离散度就会越低，如果有重复的索引值，
MySQL无法利用索引排序，基于cost来看，优化器发现走索引跟全表扫描差不多，
就不一定会用到索引。
2.最左匹配原则：一般建议建立联合索引，减少索引数量，经常用的字段建立在前
面，因为有最左匹配原则，如果不在左边，单个查询用不到索引。
3.不在频繁修改的列建索引：导致我们B+树节点Page页频繁出现分裂与合并，大大
延缓了我们的系统性能。

索引在关系型数据库中，是一种单独的、物理的对数据库表中的一列或者
多列值进行排序的一种存储结构，它是某个表中一列或者若干列值的集合，还
有指向表中物理标识这些值的数据页的逻辑指针清单。
索引的作用相当于图书的目录，可以根据目录重点页码快速找到所需要的
内容，数据库使用索引以找到特定值，然后顺着指针找到包含该值的行，这样
可以是对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

Mysql为了解决事务并发产生的问题，提供了4种隔离级别
分别是读未提交、读已提交、可重复读、可串行化

InnDB解决幻读的问题是通过MVCC和LBCC解决的。
 其中，LBCC是基于锁来实现的，当我读取某条数据或者更某个数据区间数据，会
对数据进行锁定。不允许其他线程插入新的数据，实现解决事务并发的问题。
MVCC是基于多版本并发来控制，当我一个事务开启的时候，我们会创建一个快照版
本，RR级别每次查询都只会使用查询这个快照版本的数据，如果是RC我们会重新生
成一个新的快照，进行查询


意向共享锁、意向排他锁，意向共享和意向排他锁是不会冲突的，也不会和共享锁、
排他锁发生冲突。
答：InnoDB意向锁分为意向共享锁和意向排他锁，意向共享锁和意向排他锁之间不
会发生冲突，意向锁也不会和数据行共享锁S、排他锁X发生冲突。


2.6 如何保证幂等性
• 衰减重试
• 消息重发
2.7 幂等的实现
判断重复请求。
• 状态机
• 生成 token （唯一标记）
• 数据库的唯一约束(Unique Key) -> （ MD5 ） • redis 。 setNX




Java NIO基本介绍
全程java non-blocking IO ，是一系列改进的输入/输出的新特性，被统称为NIO，是同步非阻塞的

NIO相关类都被放在java.nio 包和其子包下，并且对原java.io包中很多类进行了改写

三大核心部分：Channel(管道) ，Buffer(缓冲区)，Selector(选择器)

NIO是面向缓冲区，或者面向块编程的，数据读取到一个它稍后处理的缓冲区，需要时可在

NIO与BIO的比较
BIO以流的方式处数据，NIO以块的方式处理数据，块I/O的效率比流I/O高很多
BIO是阻塞的，NIO则是非阻塞的
BIO基于字节流和字符流进行操作，而NIO基于Channel（通道）和Buffer（缓冲区）进行操作，数据总是从通道读取数据到缓冲区，或者从缓冲区写入到通道中，Selector（选择器）用于监听多个通道的事件（比如：连接请求、数据到达等），因此使用单个线程就可以监听多个客户端通道。

Spring Cloud的子项目很多，比较常见的都是Netflix开源的组件：

Spring Cloud Config

集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。

Spring Cloud Netflix

Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。

Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；

Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；

Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；

Feign：基于Ribbon和Hystrix的声明式服务调用组件；

Zuul：API网关组件，对请求提供路由及过滤功能。

Spring Cloud Bus

用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。

Spring Cloud Consul

基于Hashicorp Consul的服务治理组件。

Spring Cloud Security

安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。

Spring Cloud Sleuth

Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。

Spring Cloud Stream

轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。

Spring Cloud Task

用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。

Spring Cloud Zookeeper

基于Apache Zookeeper的服务治理组件。

Spring Cloud Gateway

API网关组件，对请求提供路由及过滤功能。

Spring Cloud OpenFeign

基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，
在Spring Cloud 2.0中已经取代Feign成为了一等公民。



倒计时器CountDownLatch
为了能够理解 CountDownLatch，举一个很通俗的例子，运动员进行跑步比赛时，假设有 6 个运动员参与比赛，裁判员在终点会为这 6 个运动员分别计时，
可以想象每当一个运动员到达终点的时候，对于裁判员来说就少了一个计时任务。直到所有运动员都到达终点了，裁判员的任务也才完成。这 6 个运动员可以类比成 6 个线程，
当线程调用 CountDownLatch.countDown 方法时就会对计数器的值减一，直到计数器的值为 0 的时候，裁判员（调用 await 方法的线程）继续往下执行。

循环栅栏：CyclicBarrier
为了理解 CyclicBarrier，这里举一个通俗的例子。开运动会时，会有跑步这一项运动，我们来模拟下运动员入场时的情况，假设有 6 条跑道，在比赛开始时，
就需要 6 个运动员在比赛开始的时候都站在起点了，裁判员吹哨后才能开始跑步。跑道起点就相当于“barrier”，是临界点，而这 6 个运动员就类比成线程的话，
就是这 6 个线程都必须到达指定点了，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波即可。cyclic 是循环的意思，
也就是说 CyclicBarrier 当多个线程凑齐了一波之后，仍然有效，可以继续凑齐下一波。

CountDownLatch 与 CyclicBarrier 的比较
CountDownLatch 与 CyclicBarrier 都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：
CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
CountDownLatch 强调一个线程等多个线程完成某件事情。CyclicBarrier 是多个线程互等，等大家都完成，再携手共进。
调用 CountDownLatch 的 countDown 方法后，当前线程并不会阻塞，会继续往下执行；而调用 CyclicBarrier 的 await 方法，会阻塞当前线程，
直到 CyclicBarrier 指定的线程全部都到达了指定点的时候，才能继续往下执行；
CountDownLatch 方法比较少，操作比较简单，而 CyclicBarrier 提供的方法更多，比如能够通过 getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，
并且 CyclicBarrier 的构造方法可以传入 barrierAction 指定当所有线程都到达时执行的业务功能
CountDownLatch 是不能复用的，而 CyclicBarrier 是可以复用的。

信号量: semaphore
Semaphore‌可以通俗地比喻为一个停车场的入口管理系统。在这个系统中，Semaphore起到了限制同时进入停车场的车辆数量的作用，确保停车场内的车位不会被过度占用。

以一个停车场是运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，
此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，
看门人限制了可以活动的线程。假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，但是得保证最多停两辆车。对于Semaphore类而言，就如同一个看门人，
限制了可活动的线程数。

Semaphore主要方法：

Semaphore(int permits):构造方法，创建具有给定许可数的计数信号量并设置为非公平信号量。

Semaphore(int permits,boolean fair):构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量。

void acquire():从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位。

void acquire(int n):从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n=2，就相当于一辆车占了两个车位。

void release():释放一个许可，将其返回给信号量。就如同车开走返回一个车位

void release(int n):释放n个许可。

int availablePermits()：当前可用的许可数。

允许多个线程同时访问：synchronized和 ReentrantLock都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。
信号量主要用于两个目的：一个是用于多个共享资源的互斥使用，另一个用于并发线程数控制。

