https://www.cnblogs.com/crazymakercircle/p/14365820.html#autoid-h3-2-0-0

hostid地址查询
ifconfig -a              -- linux mac
ipconfig /all            -- windows



1.JPS：JVM Process Status Tool
命令格式：
jps [ options ] [ hostid ]
-q 输出虚拟机唯一ID，不输出类名、Jar名和传入main方法的参数
-m 输出传入main方法的参数
-l 输出main类或Jar的全名
-v 输出虚拟机进程启动时JVM的参数

2.jstat：JVM Statistics Monitoring Tool
命令格式：
jstat [ option vmid [interval [s | ms] [count] ] ]
jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]
jstat -class pid:显示加载class的数量，及所占空间等信息。
jstat -compiler pid:显示VM实时编译的数量等信息。
jstat -gc pid:可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。
jstat -gccapacity:可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小，如：PGCMN显示的是最小perm的内存使用量，PGCMX显示的是perm的内存最大使用量，PGC是当前新生成的perm内存占用量，PC是但前perm内存占用量。其他的可以根据这个类推， OC是old内纯的占用量。
jstat -gcnew pid:new对象的信息。
jstat -gcnewcapacity pid:new对象的信息及其占用量。
jstat -gcold pid:old对象的信息。
jstat -gcoldcapacity pid:old对象的信息及其占用量。
jstat -gcpermcapacity pid: perm对象的信息及其占用量。
jstat -gcutil pid:统计gc信息统计。
jstat -printcompilation pid:当前VM执行的信息。

查出最高cpu占用进程id  PID
top -c
获取到这个进程下面所有线程，通过查看%CPU找到最耗费CPU的是线程PID（shift+p 按cpu排序，shift+m 按内存排序）
top -Hp 84253
线程号转换成对应的16进制PID
printf '%x\n' 84303
使用jstack 获取对应的线程信息
jstack 84253 | grep -A 10 1494f


# 查看类加载和卸载情况
jstat -class    PID

#查看JIT编译器的编译情况
jstat -compiler PID

# 命令用于查看垃圾收集情况，包括新生代和老年代的垃圾收集信息。  1秒一次一共5行
jstat -gcutil   PID  1000 5

-XX:+HeapDumpOnOutOfMemoryError: 当 JVM 抛出 OOM 时，自动导出内存快照。
-XX:HeapDumpPath=<路径>: 指定快照文件的保存路径。如果没有指定这个参数，默认情况下，堆转储文件会被写入到工作目录下，文件名为 java_pid<进程id>.hprof。
 

# 打印出 Java 进程的内存快照，包括堆内存的详细信息
jmap -dump:format=b,file=/tmp/dump.hprof  PID


--- 排查情況
监控远程JVM的话，需要在启动时开启JMX管理功能（参数是：-Dcom.sun.management.jmxremote)

1、使用命令直接生成堆dump文件
发送内存溢出时，可以先使用命令生成dump文件后再重启服务。

登录虚机，执行以下jamp命令

# 替换<pid>为Java进程的ID，file:输出文件名为heap.hprof,可自定义路径
jmap -dump:format=b,file=heap.hprof <pid>
 
2、内存溢出发生时自动生成dump文件
java -jar启动服务的时候添加dump参数，服务发生内存溢出时自动生成dump文件。

-XX:+HeapDumpOnOutOfMemoryError 当OutOfMemoryError发生时生成dump文件

-XX:HeapDumpPath=生成dump文件的存储目录，如不指定默认生成在jar所在目录，目录一定要存在，否则生成失败。
# 替换<jar>为jar包的路径，<path>为生成dump文件的存储目录
# 当OutOfMemoryError发生时生成dump文件,-XX:HeapDumpPath指定生成后的文件存储路径
java -jar -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/test/dump/ -Xms64m -Xmx64m  demo-0.0.1-SNAPSHOT.jar
 



                        
新生代晋升老生代
1、对象优先在Eden区分配，当Eden区没有足够的空间时，虚拟机将发起一次Minor GC。
2、Minor GC期间，虚拟机会将Eden区和Survivor区存活的对象复制到另一块Survivor区中，然后清理Eden区和Survivor区中的对象。
3、如果Survivor区空间不足，或者对象已经存活了足够长的时间（默认15次Minor GC），那么对象将被晋升到老年代。
4、老年代是堆内存中的一部分，用于存储长期存活的对象。当老年代空间不足时，虚拟机将发起一次Full GC，清理老年代中的对象。
5、如果老年代空间仍然不足，虚拟机将抛出OutOfMemoryError异常。


1、minor gc 之后，存活于survivor 区域的对象的age会+1，当超过（默认）15的时候，转移到老年代。
2、动态对象，如果survivor空间中相同年龄所有的对象大小的综合和大于survivor空间的一半，年级大于或等于该年级的对象就可以直接进入老年代。

回收机制谁要被回收？
垃圾回收器（Garbage Collector，简称 GC）是 Java 虚拟机（JVM）中用于自动管理内存的一种机制。它负责识别和回收不再使用的对象，以防止内存泄漏。
在 Java 中，当一个对象不再被引用时，它就会被垃圾回收器标记为可回收对象。垃圾回收器会定期检查堆内存中的对象，并将那些不再被引用的对象从内存中回收。

java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同是数据区域，这些区域有各自各自的用途。主要包含以下几个部分组成：jvm在运行时期主要的内存组成
 1、程序计数器
 程序计数器占用的内存空间我们可以忽略不计，它是每个线程所执行的字节码的行号指示器。
 2、虚拟机栈
 java的虚拟机栈是线程私有的，生命周期和线程相同。它描述的是方法执行的内存模型。同时用于存储局部变量、操作数栈、动态链接、方法出口等。
 3、本地方法栈
 本地方法栈，类似虚拟机栈，它调用的是是native方法。
 4、堆
 堆是jvm中管理内存中最大一块。它是被共享，存放对象实例。也被称为“gc堆”。垃圾回收的主要管理区域。
 5、方法区
 方法区也是共享的内存区域。它主要存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（jit）编译后的代码数据。

什么时候回收？
垃圾回收器会在以下几种情况下触发回收：
1. 当堆内存不足时，垃圾回收器会自动启动，以释放不再使用的内存空间。
2. 当应用程序显式调用 System.gc() 方法时，垃圾回收器会尝试回收不再使用的对象。
3. 当垃圾回收器的内存管理策略触发时，例如当堆内存使用率达到一定阈值时，垃圾回收器会自动启动。
1、引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器+1，当引用失效，计数器-1.任何时刻计数器为0的对象就是不可能再被使用的。
优点：实现简单，判定效率高效，被actionscript3和python中广泛应用。
缺点：无法解决对象之间的相互引用问题。java没有采纳

2、可达性分析算法
通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连的时候，则证明此对象是不可用的
在java中，可以作为GCRoot的对象包括以下几种：
* 虚拟机栈中引用的对象。
* 方法区中静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法中JNI引用的对象。

第一次：对象可达性分析之后，发现没有与GCRoots相连接，此时会被第一次标记并筛选。
第二次：对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，此时会被认定为没必要执行。

什么是 JVM 参数？
JVM 参数是用于配置 Java 虚拟机（JVM）行为的参数。它们可以在 JVM 启动时通过命令行选项指定，或者在应用程序运行时通过系统属性设置。JVM 参数主要用于控制 JVM 的内存管理、垃圾回收、性能调优等方面。
例如，可以使用 -Xms 和 -Xmx 参数来设置堆内存的最小和最大大小，使用 -XX:+UseG1GC 参数来启用 G1 垃圾回收器，使用 -XX:MaxGCPauseMillis 参数来设置垃圾回收器的最大暂停时间等。

JVM 参数主要分为两大类：启动参数和运行时参数。启动参数在 JVM 启动时定义，而运行时参数则在应用程序运行过程中进行调整。

启动参数
启动参数用于控制 JVM 的启动行为和内存管理。以下是一些常见的 JVM 启动参数：

-Xms: 设置初始堆大小。
-Xmx: 设置最大堆大小。
-XX:PermSize: 设置方法区的初始大小。
-XX:MaxPermSize: 设置方法区的最大大小。
示例
设置初始堆大小为512MB，最大堆大小为2GB：
java -Xms512m -Xmx2g -XX:PermSize=256m -XX:MaxPermSize=512m -jar MyApp.jar

运行时参数
运行时参数通常用于调试和进行性能分析，包括：

-Xdebug: 启用调试。
-Xrunjdwp: 配置调试代理。
示例
开启远程调试并设置端口为5005：
java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005 -jar MyApp.jar


G1 垃圾回收 底层原理是什么？说说你的调优过程？
G1 垃圾回收器是 JDK 9 中默认的垃圾回收器，它是一种分代垃圾回收器，它将堆内存划分为多个大小相等的区域，每个区域可以是 Eden、Survivor 或 Old。G1 垃圾回收器的工作原理如下：
1. 初始标记：标记所有根对象，包括虚拟机栈中引用的对象、方法区中静态属性引用的对象、本地方法栈中 Native 方法引用的对象。
2. 并发标记：从根对象开始，遍历整个堆内存，标记所有可达的对象。
3. 最终标记：处理并发标记阶段过程中，由于并发执行，可能产生新的对象引用，需要重新标记这些对象。
4. 筛选回收：对各个区域进行回收，根据回收价值和成本进行排序，选择回收价值最大的区域进行回收。
G1 垃圾回收器的调优过程如下：
1. 设置堆内存大小：根据应用程序的需求，设置堆内存的大小，可以使用 -Xms 和 -Xmx 参数来设置。
2. 设置垃圾回收器：使用 -XX:+UseG1GC 参数来启用 G1 垃圾回收器。
3. 设置并发标记周期：使用 -XX:MaxGCPauseMillis 参数来设置并发标记周期，该参数表示垃圾回收器在并发标记阶段的最大暂停时间。
4. 设置回收区域的大小：使用 -XX:G1HeapRegionSize 参数来设置回收区域的大小，该参数表示每个回收区域的大小。
5. 设置垃圾回收器的日志级别：使用 -XX:+PrintGCDetails 参数来启用垃圾回收器的详细日志输出，可以使用 -XX:+PrintGCDateStamps 参数来启用垃圾回收器的日期戳输出。
6. 监控垃圾回收器的性能：使用 jstat 命令来监控垃圾回收器的性能，可以使用 jvisualvm 工具来监控垃圾回收器的性能。

JVM预热，你的方案是啥？
JVM 预热是指通过运行一些代码来预热 JVM，使其达到最佳性能。预热的主要目的是减少 JVM 启动时的性能开销，提高应用程序的启动速度和运行效率。以下是一些常见的 JVM 预热方案：
1. 运行一些预热代码：通过运行一些预热代码，可以预热 JVM 的类加载器、编译器和垃圾回收器等组件。例如，可以运行一些常用的类和方法，或者运行一些基准测试代码。
2. 使用 -XX:+TieredCompilation 参数：该参数可以启用分层编译，分层编译是一种优化技术，它将编译过程分为两个阶段：第一个阶段是解释执行，第二个阶段是即时编译。通过启用分层编译，可以减少 JVM 启动时的性能开销，提高应用程序的启动速度和运行效率。
3. 使用 -XX:CompileThreshold 参数：该参数可以设置即时编译的阈值，即当方法被调用多少次时，才会进行即时编译。通过设置较小的即时编译阈值，可以减少 JVM 启动时的性能开销，提高应用程序的启动速度和运行效率。
4. 使用 -XX:PretenureSizeThreshold 参数：该参数可以设置大对象的阈值，即当对象的大小超过该阈值时，会直接分配到老年代。通过设置较大的大对象阈值，可以减少 JVM 启动时的性能开销，提高应用程序的启动速度和运行效率。
5. 使用 -XX:MaxTenuringThreshold 参数：该参数可以设置对象晋升到老年代的年龄阈值，即当对象在新生代中存活了多少次垃圾回收后，才会晋升到老年代。通过设置较小的晋升年龄阈值，可以减少 JVM 启动时的性能开销，提高应用程序的启动速度和运行效率。


你们用什么版本的jdk？聊一聊不同版本的jdk的新特性？
JDK 8 是目前最常用的 JDK 版本，它引入了许多新特性和改进，包括：
Lambda 表达式：Lambda 表达式是一种简洁的语法，用于表示匿名函数，可以简化代码，提高代码的可读性和可维护性。
Stream API：Stream API 是一种用于处理集合数据的 API，它提供了一种声明式的方式来处理数据，可以简化代码，提高代码的可读性和可维护性。
默认方法：默认方法是一种在接口中定义的方法，它有默认的实现，子类可以选择继承默认实现，也可以选择重写该方法。
新时间 API：Java 8 引入了一个新的时间 API，包括 LocalDate、LocalTime、LocalDateTime、ZonedDateTime 等，这些类提供了更简单、更强大的日期和时间处理功能。
新的垃圾回收器：Java 8 引入了一个新的垃圾回收器，即 G1 垃圾回收器，它是一种分代垃圾回收器，可以更好地处理大堆内存和低延迟的应用程序。
JDK 11 是最新的 LTS（长期支持）版本，它引入了许多新特性和改进，包括：
新的垃圾回收器：JDK 11 引入了一个新的垃圾回收器，即 ZGC 垃圾回收器，它是一种低延迟的垃圾回收器，可以处理大堆内存和低延迟的应用程序。
新的字符串 API：JDK 11 引入了一个新的字符串 API，包括 isBlank()、lines()、strip() 等方法，这些方法提供了更简单、更强大的字符串处理功能。
新的集合 API：JDK 11 引入了一个新的集合 API，包括 List.of()、Set.of()、Map.of() 等方法，这些方法提供了更简单、更强大的集合处理功能。
新的流 API：JDK 11 引入了一个新的流 API，包括 takeWhile()、dropWhile() 等方法，这些方法提供了更简单、更强大的流处理功能。
JDK 8 引入了许多新特性和改进，包括 Lambda 表达式、Stream API、默认方法、新时间 API、新的垃圾回收器等。JDK 11 是最新的 LTS 版本，它引入了许多新特性和改进，包括新的垃圾回收器、新的字符串 API、新的集合 API、新的流 API 等。

 OOM后，JVM一定会退出吗？为什么？
不一定。当 JVM 发生 OutOfMemoryError 时，并不一定会退出。JVM 有一些机制来处理这种情况，例如：
1. 垃圾回收：当 JVM 发生 OutOfMemoryError 时，垃圾回收器会尝试回收不再使用的对象，以释放内存。如果垃圾回收器无法回收足够的内存，JVM 会抛出 OutOfMemoryError。
2. 内存泄漏：如果应用程序存在内存泄漏，即对象无法被垃圾回收器回收，那么 JVM 可能会一直消耗内存，直到耗尽所有可用内存。在这种情况下，JVM 可能会抛出 OutOfMemoryError，但并不会退出。
3. 系统资源耗尽：如果系统资源（如 CPU、内存、磁盘空间等）耗尽，那么 JVM 可能会抛出 OutOfMemoryError，但并不会退出。在这种情况下，应用程序可能需要重新启动，以释放系统资源。
因此，当 JVM 发生 OutOfMemoryError 时，并不一定会退出。应用程序需要根据具体情况来处理这种情况，例如通过增加内存、优化代码、修复内存泄漏等。

  Java中的对象一定是在堆上分配的吗？
 不一定。Java 中的对象可以在堆上分配，也可以在栈上分配。具体取决于对象的类型和生命周期。
对于局部变量和基本数据类型，它们在栈上分配。当方法被调用时，局部变量和基本数据类型会被压入栈中，当方法执行完毕后，它们会被自动从栈中弹出。
对于对象，它们可以在堆上分配，也可以在栈上分配。如果对象是局部变量，那么它会在栈上分配。如果对象是类的成员变量，那么它会在堆上分配。如果对象是类的静态变量，那么它会在堆上分配。


聊聊，什么是即时编译？
即时编译（Just-In-Time Compilation，JIT）是一种在程序运行时将字节码编译为机器码的技术。JIT 编译器将字节码编译为机器码，以便在运行时提高程序的执行速度。JIT 编译器通常在程序运行时进行编译，因此它可以在程序运行时根据程序的实际运行情况来优化编译结果。
JIT 编译器的工作原理如下：
1. 解释执行：JVM 在启动时，会将字节码解释执行，即逐条将字节码翻译为机器码并执行。解释执行可以立即开始执行程序，但执行速度较慢。
2. 编译执行：当 JVM 执行字节码时，JIT 编译器会监控程序的执行情况，如果发现某些代码段被频繁执行，那么 JIT 编译器会将这些代码段编译为机器码。编译执行可以显著提高程序的执行速度，但需要额外的编译时间。
3. 优化编译：JIT 编译器可以对编译后的机器码进行优化，以提高程序的执行速度。优化编译可以包括内联函数、循环展开、常量折叠等优化技术。
JIT 编译器的主要优点是它可以提高程序的执行速度，因为它可以将字节码编译为机器码。JIT 编译器的主要缺点是它需要额外的编译时间，因此在程序启动时可能会出现性能下降。此外，JIT 编译器需要占用更多的内存，因为它需要存储编译后的机器码。
JIT 编译器是 Java 虚拟机（JVM）的一部分，它将 Java 字节码编译为机器码，以便在运行时提高程序的执行速度。JIT 编译器通常在程序运行时进行编译，因此它可以在程序运行时根据程序的实际运行情况来优化编译结果。

什么是JVM的Just-In-Time（JIT）编译器？

答：JIT编译器是一种在程序运行时将字节码编译为本地机器码的编译器。这种编译可以提高程序的执行效率，因为它生成的本地代码可以充分利用现代CPU的优化特性。


Java中的String对象的大小?
Java 中的 String 对象的大小取决于其内容。在 Java 8 中，String 对象的大小包括以下部分：
1. 字符串内容：String 对象的内容是一个字符数组，每个字符占用 2 个字节。因此，字符串内容的长度乘以 2 就是字符串内容的大小。
2. 引用：String 对象还包含一个指向字符数组的引用，这个引用占用 4 个字节。
3. 对象头：String 对象还包含一个对象头，对象头的大小取决于 JVM 的实现。在 HotSpot JVM 中，对象头的大小为 8 个字节，包括一个 4 字节的标记字段和一个 4 字节的类指针。
因此，Java 中的 String 对象的大小为：字符串内容大小 + 引用大小 + 对象头大小。例如，一个长度为 10 的字符串对象的大小为：10 * 2 + 4 + 8 = 28 字节。

 说说JVM相关的类的加载、链接和初始化的问题？
类的加载、链接和初始化是 Java 虚拟机（JVM）执行 Java 程序的重要步骤。以下是这些步骤的详细解释：
类的加载：类的加载是指将类的字节码文件加载到 JVM 中，以便 JVM 可以执行该类。类的加载过程包括以下步骤：
1. 加载：JVM 通过类的全限定名（例如，java.lang.String）来加载类的字节码文件。JVM 使用类加载器（例如，Bootstrap 类加载器、Extension 类加载器和 Application 类加载器）来加载类的字节码文件。
2. 验证：JVM 验证类的字节码文件是否符合 Java 虚拟机规范，以确保类的字节码文件是安全的。
3. 准备：JVM 为类的静态变量分配内存，并将其初始化为默认值。
4. 解析：JVM 将类的符号引用解析为直接引用，例如将类名解析为类对象、将方法名解析为方法对象等。
类的链接：类的链接是指将类的字节码文件链接到 JVM 中，以便 JVM 可以执行该类。类的链接过程包括以下步骤：
1. 验证：JVM 验证类的字节码文件是否符合 Java 虚拟机规范，以确保类的字节码文件是安全的。
2. 准备：JVM 为类的静态变量分配内存，并将其初始化为默认值。
3. 解析：JVM 将类的符号引用解析为直接引用，例如将类名解析为类对象、将方法名解析为方法对象等。
类的初始化：类的初始化是指将类的静态变量初始化为其初始值，并执行类的静态初始化块。类的初始化过程包括以下步骤：
1. 初始化：JVM 执行类的静态初始化块，并将类的静态变量初始化为其初始值。
2. 执行：JVM 执行类的构造方法，创建类的实例对象。
3. 完成初始化：JVM 完成类的初始化，并将类的实例对象返回给调用者。
JVM 的类加载、链接和初始化是 Java 程序执行的重要步骤。类加载是将类的字节码文件加载到 JVM 中，链接是将类的字节码文件链接到 JVM 中，初始化是将类的静态变量初始化为其初始值，并执行类的静态初始化块。这些步骤是 JVM 执行 Java 程序的重要步骤，它们确保了 Java
程序的正确性和安全性。

问：介绍一下方法区和永久代的区别?
方法区和永久代是 JVM 中的两个内存区域，它们有一些相似之处，但也有一些区别。
方法区是 JVM 中的内存区域，用于存储类的元数据，包括类的定义、常量池、静态变量等。方法区是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。
永久代是 HotSpot JVM 中的一个内存区域，用于存储类的元数据，包括类的定义、常量池、静态变量等。永久代是方法区的一个实现，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。在 Java 8 中，永久代被移除，取而代之的是元空间（Metaspace）。
方法区和永久代的主要区别在于它们的生命周期和存储的内容。方法区是 JVM 中的内存区域，用于存储类的元数据，包括类的定义、常量池、静态变量等。方法区是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。永久代是 HotSpot JVM 中的一个内存区域，用于存储
类的元数据，包括类的定义、常量池、静态变量等。永久代是方法区的一个实现，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。在 Java 8 中，永久代被移除，取而代之的是元空间（Metaspace）。

问：如何解决堆内存溢出？
堆内存溢出通常是由于应用程序中存在内存泄漏或内存使用不当导致的。以下是一些解决堆内存溢出的方法：
1. 检查代码：检查代码中是否存在内存泄漏，例如忘记关闭数据库连接、文件流等。如果存在内存泄漏，需要修复代码中的问题。
2. 增加堆内存大小：如果应用程序需要更多的内存，可以增加 JVM 的堆内存大小。可以使用 JVM 参数 -Xmx 和 -Xms 来设置堆内存的大小。例如，可以使用以下命令来设置堆内存大小为 2GB：
   java -Xmx2g -Xms2g MyApplication
3. 使用垃圾回收器：JVM 提供了多种垃圾回收器，例如 Serial GC、Parallel GC、CMS GC、G1 GC 等。不同的垃圾回收器有不同的优缺点，可以根据应用程序的需求选择合适的垃圾回收器。例如，如果应用程序需要低延迟，可以选择 CMS GC 或 G1 GC；如果应用程序需要高吞吐量，可以选择 Parallel GC。
4. 使用内存分析工具：使用内存分析工具（例如，VisualVM、MAT、JProfiler 等）来分析应用程序的内存使用情况，找出内存泄漏的原因。这些工具可以帮助您找出内存泄漏的代码，并修复它们。

问：介绍一下JVM的垃圾回收机制？
JVM 的垃圾回收机制是自动管理内存的一种机制，它负责回收不再使用的对象所占用的内存。JVM 使用垃圾回收器（Garbage Collector，GC）来执行垃圾回收操作。垃圾回收器的工作原理如下：
1. 标记：垃圾回收器首先标记出所有仍然被引用的对象。这些对象是可达的，即它们可以通过其他对象访问到。
2. 清除：垃圾回收器然后清除所有未被标记的对象。这些对象是不可达的，即它们无法通过其他对象访问到，因此它们所占用的内存可以被回收。
3. 压缩：垃圾回收器最后将剩余的对象压缩到内存的一端，以便为新的对象腾出空间。压缩操作可以提高内存的利用率，减少内存碎片。
JVM 的垃圾回收机制可以自动回收不再使用的对象所占用的内存，从而避免内存泄漏和内存溢出。垃圾回收器的工作原理包括标记、清除和压缩，它可以自动回收不再使用的对象所占用的内存，从而提高应用程序的性能和稳定性。

问：介绍一下JVM的类加载机制？
JVM 的类加载机制是 Java 虚拟机（JVM）将 Java 类文件加载到内存中，并创建对应的 Java 类对象的过程。JVM 的类加载机制包括以下几个步骤：
1. 加载：JVM 通过类的全限定名（例如，java.lang.String）来加载类的字节码文件。JVM 使用类加载器（例如，Bootstrap 类加载器、Extension 类加载器和 Application 类加载器）来加载类的字节码文件。
2. 验证：JVM 验证类的字节码文件是否符合 Java 虚拟机规范，以确保类的字节码文件是安全的。
3. 准备：JVM 为类的静态变量分配内存，并将其初始化为默认值。
4. 解析：JVM 将类的符号引用解析为直接引用，例如将类名解析为类对象、将方法名解析为方法对象等。
5. 初始化：JVM 执行类的静态初始化块，并将类的静态变量初始化为其初始值。
JVM 的类加载机制可以确保 Java 类的正确性和安全性。类加载器负责加载类的字节码文件，验证类的字节码文件是否符合 Java 虚拟机规范，并为类的静态变量分配内存。JVM 的类加载机制可以自动加载和初始化 Java 类，从而简化了 Java 程序的开发和部署。



问：说是方法区和堆的区别？
方法区和堆是 JVM 中的两个内存区域，它们有一些相似之处，但也有一些区别。
方法区是 JVM 中的内存区域，用于存储类的元数据，包括类的定义、常量池、静态变量等。方法区是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。
堆是 JVM 中的内存区域，用于存储 Java 对象和数组。堆是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。堆中的对象可以被多个线程共享，因此需要考虑线程安全问题。
方法区和堆的主要区别在于它们存储的内容和用途。方法区是 JVM 中的内存区域，用于存储类的元数据，包括类的定义、常量池、静态变量等。方法区是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。堆是 JVM 中的内存区域，用于存储 Java 对象和数组
。堆是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。堆中的对象可以被多个线程共享，因此需要考虑线程安全问题。
问：介绍一下JVM的内存模型？
JVM 的内存模型是 Java 虚拟机（JVM）中各个线程共享的内存区域，它包括以下几个部分：
堆（Heap）：堆是 JVM 中最大的内存区域，用于存储 Java 对象和数组。堆中的对象可以被多个线程共享，因此需要考虑线程安全问题。
方法区（Method Area）：方法区是 JVM 中存储类的元数据的内存区域，包括类的定义、常量池、静态变量等。方法区是各个线程共享的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。
栈（Stack）：栈是 JVM 中每个线程私有的内存区域，用于存储局部变量、操作数栈和返回地址等。栈中的数据是线程私有的，因此不需要考虑线程安全问题。
本地方法栈（Native Method Stack）：本地方法栈是 JVM 中每个线程私有的内存区域，用于存储本地方法（即非 Java 代码）的调用栈。本地方法栈是各个线程私有的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。

问：如何设置方法区内存的大小?
在 Java 中，方法区的大小可以通过 JVM 参数来设置。具体来说，可以使用以下参数来设置方法区的大小：
-XX:MaxMetaspaceSize=<size>：设置方法区的最大大小。默认值是系统内存的 1/4。
-XX:MetaspaceSize=<size>：设置方法区的初始大小。默认值是 20.75MB。
-XX:MinMetaspaceFreeRatio=<ratio>：设置方法区空闲内存的最小百分比。默认值是 40。
-XX:MaxMetaspaceFreeRatio=<ratio>：设置方法区空闲内存的最大百分比。默认值是 70。
这些参数可以在启动 Java 应用程序时通过命令行参数来设置，例如：
java -XX:MaxMetaspaceSize=256m -XX:MetaspaceSize=128m -XX:MinMetaspaceFreeRatio=40 -XX:MaxMetaspaceFreeRatio=70 MyApplication
以上命令将方法区的最大大小设置为 256MB，初始大小设置为 128MB，空闲内存的最小百分比设置为 40，空闲内存的最大百分比设置为 70。这些参数可以根据应用程序的需求进行调整，以优化应用程序的性能和稳定性。

问：如何解决方法区的OOM？
方法区内存溢出通常是由于应用程序中存在大量的类加载或类信息导致的。以下是一些解决方法区内存溢出的方法：
1. 检查代码：检查代码中是否存在大量的类加载或类信息，例如动态加载大量的类或使用大量的反射。如果存在大量的类加载或类信息，需要修复代码中的问题。
2. 增加方法区内存大小：如果应用程序需要更多的方法区内存，可以增加 JVM 的方法区内存大小。可以使用 JVM 参数 -XX:MaxMetaspaceSize 和 -XX:MetaspaceSize 来设置方法区内存的大小。例如，可以使用以下命令来设置方法区内存大小为 256MB：
   java -XX:MaxMetaspaceSize=256m -XX:MetaspaceSize=128m MyApplication
3. 使用垃圾回收器：JVM 提供了多种垃圾回收器，例如 Serial GC、Parallel GC、CMS GC、G1 GC 等。不同的垃圾回收器有不同的优缺点，可以根据应用程序的需求选择合适的垃圾回收器。例如，如果应用程序需要低延迟，可以选择 CMS GC 或 G1 GC；如果应用程序需要高吞吐量，可以选择 Parallel GC。
4. 使用内存分析工具：使用内存分析工具（例如，VisualVM、MAT、JProfiler 等）来分析应用程序的内存使用情况，找出方法区内存溢出的原因。这些工具可以帮助您找出方法区内存溢出的代码，并修复它们。


  JVM内存包括哪些？什么是堆内存? 什么是非堆内存? 什么是直接内存? 方法区和永久代有何区别？
JVM 内存包括堆内存、非堆内存和直接内存。堆内存是 JVM 中最大的内存区域，用于存储 Java 对象和数组。非堆内存包括方法区和永久代。方法区是 JVM 中存储类的元数据的内存区域，包括类的定义、常量池、静态变量等。永久代是方法区的一个实现，它是在 JVM 启动时创建的，并且在
JVM 运行期间一直存在。直接内存是 JVM 中用于存储非堆内存的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。直接内存是 JVM 中用于存储非堆内存的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。直接内存是 JVM 中用于存储非
堆内存的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。直接内存是 JVM 中用于存储非堆内存的内存区域，它是在 JVM 启动时创建的，并且在 JVM 运行期间一直存在。直接内存是 JVM 中用于存储非堆内存的内存区域，它是在 JVM 启动时创建的，并且在


     给定一个具体的类，请分析对象的内存占用? 怎么计算出来一个对象的内存占用?对象头中包含哪些部分？
给定一个具体的类，我们可以通过以下步骤来分析对象的内存占用：
1. 计算类的实例变量：首先，我们需要计算类的实例变量的内存占用。每个实例变量都会占用一定的内存空间，具体的大小取决于变量的类型。例如，一个 int 类型的变量会占用 4 个字节，一个 long 类型的变量会占用 8 个字节，一个 double 类型的变量会占用 8 个字节，一个引用类型的变量会占用 4 个字节（
在 32 位 JVM 中）或 8 个字节（在 64 位 JVM 中）。
2. 计算对象头：每个对象都有一个对象头，它包含了对象的元数据，例如对象的哈希码、锁信息、GC 信息等。对象头的大小取决于 JVM 的实现，但通常情况下，它的大小是固定的。在 32 位 JVM 中，对象头的大小通常是 8 个字节，而在 64 位 JVM 中，对象头的大小通常是 16 个字节。
3. 计算填充：由于 JVM 的内存对齐要求，对象的内存占用必须是 8 的倍数。因此，如果对象的大小不是 8 的倍数，就需要在对象中添加填充字节，以确保对象的大小是 8 的倍数。
4. 计算对象的总大小：最后，我们需要将类的实例变量的内存占用、对象头的内存占用和填充的内存占用相加，得到对象的总大小。


常用的JVM启动参数有哪些? 调优命令有哪些？设置堆内存XMX应该考虑哪些因素？假设物理内存是8G，设置多大堆内存比较合适? 怎样开启GC日志？
常用的 JVM 启动参数包括：
-Xms：设置 JVM 初始堆内存大小。
-Xmx：设置 JVM 最大堆内存大小。
-XX:NewSize：设置新生代初始内存大小。
-XX:MaxNewSize：设置新生代最大内存大小。
-XX:SurvivorRatio：设置新生代中 Eden 区和 Survivor 区的比例。
-XX:PermSize：设置永久代初始内存大小。
-XX:MaxPermSize：设置永久代最大内存大小。
-XX:GCTimeRatio：设置垃圾回收时间占总时间的比例。
-XX:MaxTenuringThreshold：设置对象晋升到老年代的年龄阈值。
调优命令包括：
jstat：用于监控 JVM 的性能，例如内存使用情况、垃圾回收情况等。
jmap：用于查看 JVM 的内存使用情况，例如堆内存使用情况、永久代使用情况等。
jhat：用于分析 JVM 的堆内存快照，例如查找内存泄漏的原因等。
设置堆内存 XMX 的考虑因素包括：
应用程序的需求：应用程序的需求决定了堆内存的大小。如果应用程序需要处理大量的数据，那么需要更大的堆内存。
JVM 的性能：JVM 的性能也会影响堆内存的大小。如果 JVM 的性能较差，那么需要更大的堆内存来提高性能。
物理内存的大小：物理内存的大小也会影响堆内存的大小。如果物理内存较小，那么需要设置较小的堆内存，以避免内存溢出。
假设物理内存是 8GB，那么设置多大的堆内存比较合适呢？一般来说，堆内存的大小应该设置为物理内存的 1/4 到 1/2。例如，如果物理内存是 8GB，那么堆内存的大小可以设置为 2GB 到 4GB。但是，这只是一个大致的估计，
具体的堆内存大小还需要根据应用程序的需求和 JVM 的性能来决定。
怎样开启 GC 日志？
要开启 GC 日志，可以使用 JVM 参数 -XX:+PrintGCDetails 和 -XX:+PrintGCDateStamps。例如，可以使用以下命令来启动 Java 应用程序并开启 GC 日志：
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps MyApplication









java8及以后的版本使用Metaspace(元空间)来代替永久代，，Metaspace是方法区在HotSpot中的实现，它与持久代最大区别在于，Metaspace并不在虚拟机内存中而是使用本地内存也就是在JDK8中,
classe metadata(the virtual machines internal presentation of Java class),被存储在叫做Metaspace的native memory

永久代: 虚拟机加载的类信息 + 常量池 + 静态变量 + 即时编译器编译后的代码等数据;
元空间: 类信息 + 常量池 + 静态变量 + 即时编译器编译后的代码等数据;
元空间和永久代最大的区别在于：永久代使用的是JVM的堆内存，元空间使用的是物理内存，也就是说，只要物理内存足够，元空间就不会OOM。

元空间会OOM么？在什么情况下会产生内存溢出？
元空间不会OOM，元空间是物理内存，只要物理内存足够，元空间就不会OOM。

元空间会产生内存溢出么？在什么情况下会产生内存溢出？
出现错误的主要原因, 是加载到内存中的 class 数量太多或者体积太大。
解决办法: 增加 Metaspace 的大小   -XX:MaxMetaspaceSize=512m
查看元空间大小: java -XX:+PrintFlagsInitial

元空间与永久代最大区别在于:Metaspace并不在虚拟机内存中而是使用本地内存也就是在JDK8中

Java内存区域
说一下 Java 堆空间及 GC？
堆空间是 JVM 管理的内存中最大的一块，堆是进程中各个线程共享的内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配。堆空间可以细分为: 新生代(Eden + S0 + S1) + 老年代 + 永久代(方法区)
当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。

说一下 JVM 的主要组成部分及其作用？
JVM 是可运行 Java 代码的虚拟计算机系统。它包括一个指令集解释器，一个运行时数据区域，以及一组库。JVM 是 Java 平台的一部分，负责运行 Java 应用程序。
JVM 的主要组成部分有：
JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。
Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到
Runtime data area中的method area。
Execution engine（执行引擎）：执行classes中的指令。
Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。
Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。

类加载器：负责加载 .class 文件，即把类的字节码载入内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。
执行引擎：执行引擎负责执行字节码，解释器负责解释执行字节码，即时编译器编译执行字节码，编译器以方法为单位，将字节码编译成机器码。
本地库接口：本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理 C/C++程序，即本地方法栈，由于它需要与底层交互，于是称其为 Native Interface。
运行时数据区：运行时数据区是 JVM 所管理的内存，也是 Java 程序运行的真正环境，它主要包括以下部分：
方法区（Method Area）：方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
堆（Heap）：堆是各个线程共享的内存区域，它在虚拟机启动时创建。堆是 Java 对象的存储区域，所有的对象实例以及数组都要在堆上分配。堆被划分为新生代和老年代。新生代又被划分为 Eden 空间、From Survivor 空间和 To Survivor 空间。
栈（Stack）：栈是每个线程私有的内存区域，它用于存储局部变量、操作数栈、动态链接、方法出口等信息。栈分为虚拟机栈和本地方法栈，虚拟机栈用于执行 Java 方法，本地方法栈用于执行 Native 方法。
程序计数器（Program Counter Register）：程序计数器是每个线程私有的内存区域，它用于存储当前线程所执行的字节码的行号指示器。


JVM内存包括哪些？
堆内存（Heap）: 存放对象实例和数组，是线程共享的，堆内存是 JVM 管理的内存中最大的一块，堆是进程中各个线程共享的内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配。堆空间可以细分为:
 新生代(Eden + S0 + S1) + 老年代 + 永久代(方法区)。
方法区（Method Area）: 存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的。
栈内存（Stack）: 存放局部变量表、操作数栈、动态链接、方法出口等信息，是线程私有的。
程序计数器（Program Counter Register）: 每个线程都有一个程序计数器，用于记录当前线程正在执行的虚拟机字节码指令的地址。
本地方法栈（Native Method Stack）: 用于执行本地方法（Native Method），是线程私有的。

JVM总内存= 栈 + 堆 +Native
Native= 堆外内存（直接内存） + 元空间
非堆 = 元空间

本地方法栈和虚拟机栈的主要区别？
虚拟机栈执行的是java方法
本地方法栈执行的是native方法

什么是堆内存?
堆内存是 JVM 管理的内存中最大的一块，堆是进程中各个线程共享的内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配。
堆空间可以细分为: 新生代(Eden + S0 + S1  (1 伊甸园区 + 2 幸存者区 , 一般称为年轻代。)) + 老年代 + 永久代(方法区, 1.8后永久代被元空间取代了)。

在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值;
堆内内存 = 新生代+老年代

常见的垃圾回收算法主要有？
引用计数器法（Reference Counting）
标记清除法（Mark-Sweep）
复制算法（Coping）
标记压缩(整理)法（Mark-Compact）
分代算法（Generational Collecting）
分区算法（Region）

JVM内存连环炮：什么是非堆内存?
除堆内存之外，JVM的内存池还包括非堆（NON_HEAP），
非堆内存 大概包括：
MetaSpace   元空空间
CodeCache   代码缓存
Compressed Class Space    压缩类空间

什么是堆外内存/直接内存（direct memory）？
堆外内存, 常常又叫做直接内存。 和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

介绍一下方法区和永久代的区别
方法区是 JVM 规范中定义的一块区域，用于存储类信息、常量池、静态变量等数据，而永久代是 HotSpot 虚拟机对方法区的一种实现方式。
在 JDK 1.8 之前，HotSpot 虚拟机使用永久代来实现方法区，而在 JDK 1.8 之后，永久代被元空间（Metaspace）所取代。


为什么用元空间替换永久代？
为永久代设置最大空间大小是难以确定的。对永久代进行调优是很困难的。
元空间使用的是物理内存，也就是说，只要物理内存足够，元空间就不会OOM。元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的最大大小仅受本地内存限制。

为什么调整字符串常量池的位置？
字符串常量池在JDK1.7之前是放在了永久代中的，而在JDK1.7之后，字符串常量池被移到了堆内存中。这是因为永久代的空间有限，而字符串常量池中的字符串数量可能会非常大，如果字符串常量池放在永久代中，可能会导致永久代内存不足，
从而引发OutOfMemoryError。将字符串常量池移到堆内存中，可以避免这个问题，同时也可以更好地管理字符串常量池中的字符串。

JDK7中将字符串常量池放到了堆空间中：因为永久代的回收效率很低，在Full GC时才会触发，而Full GC在老年代的空间不足、永久代不足时才会触发，这就导致字符串常量池回收效率不高；
而我们开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。将字符串常量池放到堆里，能及时回收内存。



什么是执行引擎？
执行引擎是 JVM 的核心组成部分之一，它负责执行 Java 字节码。执行引擎包括解释器和即时编译器两部分。解释器负责逐行解释执行 Java 字节码，而即时编译器则负责将 Java 字节码编译成本地机器码，以提高程序的执行效率。执行引擎是
JVM 的核心组成部分之一，它负责执行 Java 字节码。执行引擎包括解释器和即时编译器两部分。解释器负责逐行解释执行 Java 字节码，而即时编译器则负责将 Java 字节码编译成本地机器码，以提高程序的执行效率。

执行引擎是 java 虚拟机的最核心组件之一，它负责执行虚拟机的字节码，有即时编译和解释执行，通常采用解释执行方式。解释执行是指解释器通过每次解释并执行一小段代码来完成.class程序的所有操
作。即时编译则是将.class文件翻译成机器码在执行（比如：经常多次访问的代码可以全部编译）
垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对 栈 堆进行回收。其中， java 堆是垃圾收集器的工作重点。有三类：增量垃圾回收，分代复制垃圾回收，标记垃圾回收
和 C/C++不同， java 中所有的对象空间释放都是隐式的，也就是说， java 中没有类似 free()或者 delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。



成员变量、局部变量、类变量分别存储在内存的什么地方？
成员变量：成员变量存储在堆内存中，包括静态变量和实例变量。静态变量在类加载时分配内存，实例变量在对象创建时分配内存。
局部变量：局部变量存储在栈内存中，包括方法参数和方法的局部变量。局部变量在方法调用时分配内存，方法调用结束后，局部变量所占用的内存会被释放。
类变量：类变量存储在方法区中，包括静态变量和实例变量。静态变量在类加载时分配内存，实例变量在对象创建时分配内存。

类变量:
类变量是用static修饰符修饰，定义在方法外的变量，包括静态变量和实例变量。
随着java进程产生和销毁在java8之前把静态变量存放于方法区，在java8时存放在堆中
成员变量:
成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例的一部分
由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象一起放入堆中
局部变量:
局部变量是定义在类的方法中的变量在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟机栈中


类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？
类常量池、运行时常量池、字符串常量池是 Java 虚拟机中用于存储常量的三个不同区域。
类常量池与运行时常量池都存储在方法区，而字符串常量池在jdk7时就已经从方法区迁移到了java堆中。
在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和符号引用，而字面量的一部分便是文本字符，在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池；
对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池；字符串常量池存储的是字符串对象的引用，而不是字符串本身。

类常量池（Class Constant Pool）：类常量池是每个类或接口的常量池，用于存储编译期生成的各种字面量和符号引用。类常量池在编译时被写入到类的字节码文件中，并在类加载时被加载到方法区中。
运行时常量池（Runtime Constant Pool）：运行时常量池是方法区的一部分，用于存储在类加载时生成的常量池的运行时表示形式。运行时常量池在类加载时被创建，并在程序运行期间可以被修改。
字符串常量池（String Constant Pool）：字符串常量池是方法区的一部分，用于存储字符串常量。字符串常量池在类加载时被创建，并在程序运行期间可以被修改。


使用堆外内存的优点
减少了垃圾回收 因为垃圾回收会暂停其他的工作。
加快了复制的速度 堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略 掉了这个工作。  这样就避免了在 Java堆和 Native 堆中来回复制数据

深拷贝和浅拷贝?
浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，
深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。
浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。



说一下堆栈的区别？
堆和栈是 Java 虚拟机中两种不同的内存区域，它们各自有不同的用途和特点。
堆（Heap）：堆是 Java 虚拟机中用于存储对象实例的区域，所有的对象实例都在堆上分配内存。堆是线程共享的，多个线程可以同时访问堆中的对象。堆的大小可以动态调整，可以通过 JVM 参数来设置堆的大小和调整策略。
栈（Stack）：栈是 Java 虚拟机中用于存储方法调用和局部变量的区域。栈是线程私有的，每个线程都有自己独立的栈。栈的大小是固定的，一旦栈的大小超过了设定的值，就会发生栈溢出（StackOverflowError）。
堆和栈的区别主要有以下几个方面：
存储内容：堆用于存储对象实例，栈用于存储方法调用和局部变量。
共享性：堆是线程共享的，栈是线程私有的。
内存管理：堆的内存管理是由垃圾回收器自动进行的，栈的内存管理是由 JVM 自动进行的。


物理地址
堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩(整理)，分代（即新生代使用复制算法，老年代使用标记——压缩(整理)）
栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。
内存分别
堆因为是不连续的，所以分配的内存是在 运行期 确认的，因此大小不固定。一般堆大小远远大于栈。
栈是连续的，所以分配的内存大小要在 编译期 就确认，大小是固定的
存放的内容
堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行
1. 静态变量放在方法区
2. 静态的对象还是放在堆
程序的可见度
堆对于整个应用程序都是共享、可见的。
栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同

Java 中堆和栈有什么区别？
JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程

队列和栈是什么？有什么区别？
队列（Queue）和栈（Stack）是两种基本的数据结构
队列是一种先进先出（FIFO）的数据结构，它支持两种基本操作：入队（enqueue）和出队（dequeue）。入队操作将一个元素添加到队列的尾部，而出队操作则从队列的头部移除一个元素。队列通常用于实现缓冲区、任务队列等场景。
栈是一种后进先出 - 先进后出（LIFO）的数据结构，它支持两种基本操作：入栈（push）和出栈（pop）。入栈操作将一个元素添加到栈的顶部，而出栈操作则从栈的顶部移除一个元素。栈通常用于实现函数调用、表达式求值等场景。
队列和栈的区别主要体现在它们的操作方式和用途上。队列是一种先进先出的数据结构，它支持入队和出队两种操作，适用于实现缓冲区、任务队列等场景。而栈是一种后进先出的数据结构，它支持入栈和出栈两种操作，
适用于实现函数调用、表达式求值等场景。另外，队列通常用于实现多线程之间的数据共享，而栈通常用于实现单线程中的数据共享。

队列和栈都是被用来预存储数据的。
操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。
可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。
操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,
即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。


虚拟机栈(线程私有)
每个线程运行时所需要的内存，称为虚拟机栈。每个线程创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Frame）,对应着一次次的Java方法调用。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。
本地方法栈(线程私有)
与虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。


什么是直接内存？
直接内存（Direct Memory）是Java虚拟机（JVM）中的一种内存区域，它不是Java堆的一部分，而是直接由操作系统管理的内存。直接内存通常用于处理I/O操作，例如读写文件、网络通信等。直接内存不受Java堆的大小限制，
因此可以比堆内存更快地处理大量数据。但是，直接内存的分配和释放需要手动进行，如果忘记释放，可能会导致内存泄漏。 

直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用:
在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避
免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。

答：直接内存是Java NIO中引入的一种内存类型，它允许Java程序直接在JVM和操作系统之间传输数据，绕过传统的堆内存。这样可以提高I/O操作的效率，因为它减少了数据在用户态和内核态之间的复制次数。

对象的访问定位
指针： 指向对象，代表一个对象在内存中的起始地址。
句柄： 可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的真实内存地址。

java内存模型（Java Memory Model，JMM）是Java虚拟机（JVM）中定义的一种规范，用于描述Java程序中多线程之间的内存访问行为。JMM规定了Java程序中各个线程如何访问共享变量，以及如何保证多线程环境下的数据一致性。
java基础数据类型有
byte、short、int、long、float、double、boolean、char、void


什么是Java内存模型（Java Memory Model, JMM）？

答：JMM定义了Java程序中各种变量（线程栈中的局部变量、方法区中的静态属性等）的访问规则，以及在并发环境下如何保证内存的可见性和有序性。JMM是实现多线程程序正确性的关键。
jmm(Java Memory Model):内存模型与线程规范,java内存模型围绕着并发过程中如何处理可见性,原子性,有序性这三个特性而建立的模型
内存模型主要是描述程序中各个变量之间的关系,以及在实际计算机系统中将变量存储到内存和从内存中取出变量到底层细节
主内存(Main Memory)：JMM规定所有的变量存储在主内存中,每个线程还有自己的工作内存(Working Memory)


怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？
你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息


JRE、JDK、JVM 及 JIT 之间有什么不同？
JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。
JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。
JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。
JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。


Java会存在内存泄漏吗？
是的，Java存在内存泄漏的情况。
内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java是有GC垃圾回收机制的，也就是说，不再被使用的对象，会被GC自动回收掉，自动从内存中清除。
但是，即使这样，Java也还是存在着内存泄漏的情况，java导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为
长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。

什么情况下会发生栈内存溢出。
栈内存溢出通常发生在以下几种情况下：
1. 递归调用过深：当递归调用过深时，会导致栈溢出。例如，一个无限递归调用，或者递归深度超过了栈的最大深度。
2. 栈帧过大：当栈帧过大时，会导致栈溢出。例如，当方法中的局部变量过多，或者方法参数过多时，可能会导致栈帧过大。
3. 栈空间不足：当栈空间不足时，会导致栈溢出。例如，当系统中的线程数过多时，可能会导致栈空间不足。

栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型
如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常，方法递归调用产生这种结果。
如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。(线程启动过多)
参数 -Xss 去调整JVM栈的大小



简述Java垃圾回收机制
Java垃圾回收机制是Java虚拟机（JVM）中的一种自动内存管理机制，用于回收不再使用的对象所占用的内存空间。垃圾回收机制的主要目标是减少内存泄漏和内存碎片，提高程序的性能和稳定性。
在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不
足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
Java垃圾回收机制主要依赖于以下几种算法：
1. 标记-清除算法：标记-清除算法是Java垃圾回收机制中最基本的算法之一。它首先标记出所有需要回收的对象，然后清除这些对象所占用的内存空间。这种算法的优点是简单易实现，但是缺点是会产生内存碎片。
标记阶段：从 GC Roots 开始遍历，找到可达对象，并在对象头中进行记录。
清除阶段：堆内存空间进行线性遍历，如果发现对象头中没有记录是可达对象，则回收它。
缺点：
效率不高，和后面讲的算法来比效率确实不高。
内存碎片，对象被清除后会留下一块一块的小内存，由于这些小内存不是连续的，所以很可能不够存储新来的大对象。
优点：
思路简单。

2. 复制算法：复制算法是一种将内存空间分为两个相等的区域，每次只使用其中一个区域。当需要回收内存时，将存活的对象复制到另一个区域，然后清空当前区域。这种算法的优点是不会有内存碎片，但是缺点是内存利用率较低。
优点：
只遍历一次，效率高。
不会出现内存碎片。
缺点：
需要更多的内存，始终有一半的空闲内存。
对象复制后，对象的内存地址发生了变化，需要额外的时间修改栈帧中记录的引用地址。
如果可达对象比较多，垃圾对象比较少，那么复制算法的效率就会比较低，所以新生代特别适合复制算法，因为新生代的垃圾对象比较多（但也不绝对）。

3. 标记-整理算法：标记-整理算法是标记-清除算法的改进版。它首先标记出所有需要回收的对象，然后将存活的对象向一端移动，最后清空边界以外的内存空间。这种算法的优点是不会有内存碎片，也不会浪费内存空间。
优点：

不会出现内存碎片。
也不需要利用额外的内存空间。
缺点：

效率要低于标记清除算法、复制算法。
也需要修改栈帧中的引用地址。

4. 分代收集算法：分代收集算法是一种将内存空间分为多个区域，每个区域根据对象的生命周期不同，采用不同的垃圾回收算法。例如，新生代使用复制算法，老年代使用标记-整理算法。这种算法的优点是能够提高垃圾回收的效率，减少内存碎片和内存浪费。





GC是什么？为什么要GC
GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而
达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。


垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
对于 Java 程序员来说，是透明的。虚拟机自动管理内存，包括（堆、栈、方法区）的分配和回收。内存分配时按照对象的生命周期进行分配的，即程序中声明一个变量时，java就在栈中为这个变量分配内存空间，当该变量
的生命周期结束时，java会自动释放掉该对象所占用的内存空间，栈中的数据是自动释放的，但是堆中的数据，程序结束时，操作系统才会回收。

通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间
程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。


你能保证 GC 执行吗？
不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC的执行


Java 中都有哪些引用类型？
强引用：发生 gc 的时候不会被回收。
软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
弱引用：有用但不是必须的对象，在下一次GC时会被回收。
虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。


怎么判断对象是否可以被回收？
判断对象是否可以被回收主要有两种方法：
1. 引用计数法：为每个对象创建一个引用计数器，每当有一个地方引用这个对象时，计数器就加一；当引用失效时，计数器就减一；任何时刻计数器为0的对象就是不可能再被使用的。
2. 可达性分析算法：通过一系列的称为 "GC Roots" 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。

引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。
为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，
不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。



新生代
是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC
进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。
Eden 区
Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。
Servivor from 区
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。
Servivor to 区
保留了一次 MinorGC 过程中的幸存者。
MinorGC 的过程（复制->清空->互换）
MinorGC 采用复制算法。
1. eden、 servicorFrom 复制到 ServicorTo，年龄+1
首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；
2. 清空 eden、 servicorFrom
然后，清空 Eden 和 ServicorFrom 中的对象；
3. ServicorTo 和 ServicorFrom 互换
最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。
老年代
主要存放应用程序中生命周期长的内存对象。
老年代的对象比较稳定，所以 MajorGC （常常称之为 FULL GC）不会频繁执行。在进行 FULL GC前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法
找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。FULL GC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对
象。 ajorGC 的耗时比较长，因为要扫描再回收。 FULL GC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。
永久代 （或者 jdk1.8元空间）
指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被放入永久区域， 它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。


JVM内存为什么要分成新生代，老年代，永久代。新生代中为什么要分为Eden和Survivor。
1. 分成新生代和老年代是为了方便垃圾回收。
2. 新生代分为Eden和Survivor是为了方便复制算法的进行。
这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收

共享内存区划分:
共享内存区 = 永久代 + 堆
永久代 = 方法区 + 其他
Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1

参数的配置
默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。
默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定) Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)

为什么要分为Eden和Survivor?为什么要设置两个Survivor区？
因为存在内存碎片的问题，新生代分为Eden和Survivor区是为了方便复制算法的进行。

如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。
Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。
设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，
Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）


JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代
Java堆 = 老年代 + 新生代
新生代 = Eden + S0 + S1
当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。
大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；
如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。
老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存
堆 – 包括年轻代和年老代。
Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。

什么是分代，分代的必要性
分代：将对象根据存活时间进行分类，存活时间长的放入年老代，存活时间短的放入新生代，新生代存活时间短，频繁GC，年老代存活时间长，不常GC。
分代的必要性：新生代存活时间短，频繁GC，年老代存活时间长，不常GC，分代就是为了使JVM更好的管理堆内存中的对象，包括内存的分配以及回收。

Java 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对HotSpot 虚拟机而言）
JDK 1.7 之前，Java 虚拟机将堆内存划分为新生代、老年代和永久代（或者元空间）
给堆内存分代 是为了提高对象内存分配和垃圾回收的效率   分代收集大大提升了收集效率，这些都是内存分代带来的好处。
堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中
新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回
永久代（或者元空间）中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。


JVM中的永久代中会发生垃圾回收吗
永久代（PermGen）是HotSpot JVM特有的概念，它用来存放Class和Meta（元数据）的信息，Class在被加载的时候被放入永久代。永久代的大小在启动JVM的时候通过参数-XX:MaxPermSize来设定。Java8之后，永久代被移除，取而代之的是元空间（Metaspace）。
元空间使用的是直接内存，所以它的最大值只受本地内存限制，同时，类元数据分配不会导致OutOfMemoryError，因为不会出现永久代内存溢出的问题，但会抛出OOM错误，因为受限于本地内存。
垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。


Minor GC与Full GC分别在什么时候发生？
新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC


垃圾收集算法有哪些类型？
GC最基础的算法有三类： 标记 -清除算法、复制算法、标记-压缩(整理)算法，我们常用的垃圾回收器一般都采用分代收集算法。
标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
标记-压缩(整理)算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法


说一下 JVM 有哪些垃圾回收算法？
标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。
复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。


说一下 JVM 有哪些垃圾回收器？
Serial收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代都会用。
ParNew收集器，Serial收集器的多线程版本，新生代、老年代都会用，新生代采用复制算法，老年代采用标记-压缩算法。
Parallel收集器，类似ParNew收集器，Parallel收集器更关注系统的吞吐量。新生代采用复制算法，老年代采用标记-压缩算法。
CMS（Concurrent Mark Sweep）收集器，是一种以获取最短回收停顿时间为目标的收集器。新生代采用标记-清除算法，老年代采用标记-整理算法。
G1收集器，一种兼顾吞吐量和停顿时间的收集器。G1收集器将堆划分为多个大小相等的独立区域，新生代和老年代不再物理隔离。

Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；
ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；
Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量= 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；
Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；
Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；
CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。

Serial 与 Parallel GC 之间的不同之处？
Serial GC 使用单线程对整个堆进行回收，Stop-The-World 会对用户线程产生较大影响，适用于对暂停时间要求不高的场景。
Parallel GC 使用多线程对整个堆进行回收，能够减少 GC 带来的暂停时间，提高系统的吞吐量，适用于对吞吐量要求较高的场景。
Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。


类似的问题：你知道哪几种垃圾收集器，各自的优缺点，重点讲下
cms和G1，包括原理，流程，优缺点。
思路： 一定要记住典型的垃圾收集器，尤其cms和G1，它们的原理与区别，涉及的垃圾回收算法。
参考答案：
1）几种垃圾收集器：
Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。
Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。 适用场景：主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也
Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。
2）CMS收集器和G1收集器的区别：
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。



详细介绍一下 CMS 垃圾回收器？
CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”
来指定使用 CMS 垃圾回收器。
CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。


// G1 收集器参数设置
-XX:+UseG1GC -Xmx32g -XX:MaxGCPauseMillis=200
// -XX:+UseG1GC —— 为开启G1垃圾收集器，
// -Xmx32g —— 设计堆内存的最大内存为32G，
// -XX:MaxGC


简述分代垃圾回收器是怎么工作的？
分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是2/3。
新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：
把 Eden + From Survivor 存活的对象放入 To Survivor 区；清空 Eden 和 From Survivor 分区；
From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是15）时，升级为老生代。大对象也会直接进入老生代。
老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。


什么时候会触发FullGC？
除直接调用System.gc外 ,Full GC触发的情况有以下几种：
1、Young GC后，存活的对象大于老年代的剩余空间
2、晋升到老年代的对象大小大于老年代的剩余空间
3、大对象直接进入老年代，而老年代的剩余空间小于该对象大小
4、老年代空间不足
5、方法区空间不足
6、通过Minor GC后进入老年代的平均大小大于老年代的剩余空间
7、永久代空间不足


1.旧生代空间不足
老生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
java.lang.OutOfMemoryError: Java heap space
为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

2.Permanet Generation空间满
PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么
JVM会抛出如下错误信息：
java.lang.OutOfMemoryError: PermGen space为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。

3.CMS GC时出现promotion failed和concurrent mode failure
对于采用CMS进行老生代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。
promotionfailed是在进行Minor GC时，survivor space放不下、对象只能放入老生代，而此时老生代也放不下造成的；concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老生代，而此
时老生代空间不足造成的。应对措施为：增大survivorspace、老生代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕后很久才触发sweeping动作。对于这种状况，可
通过设置-XX:CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。

4.统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间
这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小
大于旧生代的剩余空间，那么就直接触发Full GC。例如程序第一次触发MinorGC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，则执行Full GC。
当新生代采用PSGC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否大于6MB，如小于，则触发对旧生代的回收。除
了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次 Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间
隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc



方法区的垃圾回收
方法区主要回收两部分内容：废弃的常量和不再使用的类型。
运行时常量池中废弃的常量
常量池中主要存放两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
类和接口的全限定名
字段的名称和描述符
方法的名称和描述符
常量池中的其他类、接口、字段、方法符号引用也具备“多态性”，并允许被动态链接。当常量池中的这些常量被应用时，必须经过解析（resolve）成为符号引用对应的直接引用。解析动作主要针对类或接口的、字段或方法的符号引用进
行，最终它们都会被转换为直接引用。直接引用可以是下面三种类型之一：
直接指向目标的指针（如指向“类对象”的指针）
相对偏移量（如指向实例变量或方法的偏移量）
一个能间接定位到目标的句柄
对于类、接口、字段、方法等类的符号引用，如果它们曾经被使用过，则不会在方法区被回收。不过，如果该符号引用对应的类对象或资源已经被卸载，则该符号引用需要被回收。

不再使用的类型
判定一个类型是否属于“不再被使用的类”的条件相对比较苛刻，需要同时满足下面三个条件：
该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
Java虚拟机被允许对满足上述三个条件的无用类进行回收，判定是否为无用类的操作是发生在GC Roots分析中。


说方法区和堆的区别？
逻辑上，方法区是属于堆的一部分 但实现上，一些简单的jvm实现，可能不会对方法区选择进行垃圾收集或者进行压缩。  HotSpot虚拟机的方法区还有一个别名，叫做 Non-Heap（非堆） ，目的就是要和堆分开
方法区看作是一块独立于Java堆的内存空间
 

方法区和堆都是线程共享的内存区域，但方法区和堆又有所不同，堆是线程共享的内存区域，堆用于存放对象实例，而方法区用于存储类信息、常量、静态变量等数据。方法区在JVM启动时被创建，堆在JVM启动时和堆中的对象一起被创建。
堆在JVM运行期间可以被动态地分配和回收，而方法区在JVM运行期间无法被动态地分配和回收。方法区的大小可以通过参数-XX:MaxPermSize来设置，而堆的大小可以通过参数-Xms和-Xmx来设置。
方法区是堆的一个逻辑部分，用于存储类信息、常量、静态变量等数据。堆是用于存储对象实例的内存区域。 

方法区是各线程共享的内存区域。
方法区在JVM启动的时候被创建，它的实例的物理内存空间可以是不连续的。
方法区的大小，可以选择固定大小或者可扩展。如果方法区无法满足新的内存分配需求时，将抛出OOM异常。
方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，会导致方法区溢出，虚拟机会抛出内存溢出错误：或者比如，以下情况：
加载大量的第三方的jar包；
Tomcat部署的工程过多（30-50个）；
java.lang.OutOfMemoryError: PermGen space
java.lang.OutOfMemoryError: Metaspace
大量动态的生成反射类。

关闭JVM就会释放该区域的内存

在JDK7及以前，习惯上把方法区称为 永久代（PermGen） ，从JDK8开始，使用 元空间 （Metaspace） 作为方法区的实现。
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者的最大区别是：元空间不在虚拟机设置的内存中，而是使用本地内存。


如何解决方法区的OOM？
方法区内存溢出，一个比较典型的场景就是在运行时产生大量的动态类。 比如CGLIB、反射、JSP应用、动态代理、大量JSP或动态生成JSP文件的应用等。
解决方法区内存溢出的方法：
-XX:MaxPermSize=512m

要解决OOM异常或heap space的异常，一般手段是通过内存映像分析工具（如 Eclipse Memory Analyzer）对dump出来的堆转储快照文件进行分析，
重点是确认内存中的对象是否还都是必要存活的，即要先分清楚到底是出现了 内存泄漏（Memory Leak） 还是 内存溢出（Memory Overflow） 。
如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，就能找到泄漏对象是通过怎样的路径与 GC Roots相关联，并导致垃圾收集器无法自动回收它们的。掌握泄漏对象的类型信息，以及 GC Roots引用链的信息后，
就可以比较准确地定位出泄漏代码的位置。
如果不存在内存泄漏，即内存中的对象确实都还必须存活着，就应当根据机器物理内存，检查虚拟机的堆参数（-Xmx与-Xms），看是否还可以调大；从代码上检査是否存在某些对象生命周期过
长、持有状态时间过长的情况（其实也算是内存泄漏），尝试减少程序运行期的内存消耗。

线上内存泄漏如何处理？
1.分析dump文件，确认内存占用情况，确认是内存泄漏还是内存溢出。
2.如果是内存泄漏，分析泄漏对象的类型和引用链，找到泄漏原因，修改代码。
3.如果是内存溢出，分析内存使用情况，调整堆大小参数，增加内存。


内存泄漏和内存溢出的区别？
内存泄漏是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。
内存溢出是指程序在申请内存时，没有足够的内存供申请者使用，出现out of memory的情况。


如何设置方法区内存的大小
-XX:MaxPermSize=512m -XX:PermSize=512m
方法区的大小不是固定的，JVM可以根据应用的需要进行动态调整。

JDK7及之前：
通过 -XX:Permsize 来设置永久代的初始分配空间，默认值是20.75M。
通过 -XX:MaxPermsize 来设置永久代的最大可分配空间，32位机器默认是64M，64位机器模式是82M。
当JVM加载的类信息容量超过最大值，会报异常OutOfMemoryError: PermGen space。

JDK8及之后：
通过设置参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来设置元空间的初始分配空间和最大可分配空间。
上述参数的默认值依赖于平台，Windows系统下，-XX:MetaspaceSize是21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。
如果不指定元空间大小，使用默认值，方法区可能耗尽所有的可用系统内存。如果元空间发生溢出，虚拟机会抛出异常OutOfMemoryError:Metaspace。
通过-XX:Metaspacesize设置的初始元空间大小是一个初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载不再使用的类，然后这个高水位线将会重置。新的高水位线的值取决于
GC后释放了多少元空间，如果释放的空间不足，那么在不超过 MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。所以，如果初始化的高水位线设置过低，高水位线调
整情况会发生很多次，通过垃圾回收器的日志，可以观察到Full GC多次调用。为了避免频繁FullGC，建议将-XX:MetaspaceSize设置为一个相对较高的值。


内存分配策略
所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。
Minor GC 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；
Major GC/Full GC 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。
对象优先在 Eden 区分配
大对象直接进入老年代
长期存活对象将进入老年代  ： 对象在 Survivor 区 中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。


对象分配规则
1. 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
2. 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
3. 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
4. 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
5. 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,
如果false则进行Full GC


简述java类加载机制?
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。


描述一下JVM加载Class文件的原理机制
JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
类加载器：类加载器就是根据指定全限定名（类名）加载类的二进制字节码到JVM中。它的作用就是将字节码文件加载到内存中，并生成一个代表该类的Class对象。类加载器只负责加载，至于类的连接和初始化，则由虚拟机来完成。
类加载器种类：
启动类加载器（Bootstrap ClassLoader）：负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，该加载器是使用C++语言实现的，嵌套在JVM内部，它无法被Java程序直接引用。
扩展类加载器（Extension ClassLoader）：负责加载Java的扩展库，默认加载JAVA_HOME/lib/ext/目下的jar包，开发者可以通过环境变量JAVA_HOME和java.ext.dirs来自定义该加载器要加载的jar包路径。
应用程序类加载器（Application ClassLoader）：负责加载用户类路径（ClassPath）上所指定的类库，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
自定义类加载器：开发人员可以通过继承java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。
类加载过程：加载、验证、准备、解析、初始化。
加载：加载是类加载的第一个过程，主要完成以下三件事：
通过一个类的全限定名来获取定义此类的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
验证：验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中。

解析：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

初始化：初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，
静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但是不能访问。静态语句块可以用来初始化静态变量。


Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。
类装载方式，有两种 ：
1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，
2.显式装载， 通过class.forname()等方法，显式加载需要的类Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。
这当然就是为了节省内存开销





描述一下 JVM 加载 class 文件的原理机制
JVM 中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java 中的类加载器是一个重要的Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。
由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类
的加载是指把类的.class 文件中的数据读入到内存中，通常是创建一个字节数组读入.class 文件，然后产生与所加载类对应的 Class 对象。
加载完成后，Class 对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后 JVM 对
类进行初始化，包括：
1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；
2)如果类中存在初始化语句，就依次执行这些初始化语句。类的加载是由类加载器完成的，
类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader 的子类）。
从 Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM 更好的保证了 Java 平台的安全性，在该机制中，JVM 自带的Bootstrap 是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM 不会
向 Java 程序提供对 Bootstrap 的引用。
下面是关于几个类加载器的说明：
1. Bootstrap：一般用本地代码实现，负责加载 JVM 基础核心类库（rt.jar）；
2. Extension：从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap；
3. System：又叫应用类加载器，其父类是 Extension。它是应用最广泛的类加载器。它从环境变量classpath 或者系统属性
java.class.path 所指定的目录中记载类，是用户自定义加载器的默认父加载器。




什么是类加载器，类加载器有哪些?
负责加载.class文件到JVM内存，类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java
程序员提供了访问方法区内的数据结构的接口。
类加载器分类：
1. Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类。
2. Extension ClassLoader：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/ext目录下的jar包和java.ext.dirs系统变量指定的目录中的jar包，由Java语言实现，父类加载器为Bootstrap。
3. App ClassLoader：负责加载应用程序classpath目录下的jar包及目录中的class，父类加载器为Extension。
4. Custom ClassLoader：用户自定义的类加载器，父类加载器为AppClassLoader。

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。
主要有一下四种类加载器:
1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。


说一下类装载的执行过程？
类装载分为以下 5 个步骤：加载、验证、准备、解析、初始化。
1. 加载是类装载的第一个阶段，在这个阶段，虚拟机需要完成以下三件事情：
通过一个类的全限定名来获取定义此类的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
2. 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在内存中实例化了一个 java.lang.Class 对象。接下来程序清单进入连接阶段，连接阶段又可细分为验证、准备和解析三个步骤。


加载：根据查找路径找到相应的 class 文件然后导入；
验证：检查加载的 class 文件的正确性；
准备：给类中的静态变量分配内存空间；
解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直
接引用直接指向内存中的地址；
初始化：对静态变量和静态代码块执行初始化工作。



什么是双亲委派模型？
类加载器分类：
启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；
其他类加载器：
扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；
应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，
只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。


简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
怎么打破双亲委派模型？
可以打破，双亲委派模型只是Java虚拟机的一种加载类的方式，不是强制性的。我们可以自己定义一个类加载器，重写类加载方法，不按照双亲委派的方式类加载，而是自己先加载。
打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。

双亲委派模型工作过程是：
如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载

什么是类加载器？
   类加载器 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。

为什么需要双亲委派模型？
在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？
防止内存中出现多份同样的字节码

类加载器就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。
类加载器分为启动类加载器、扩展类加载器、应用程序类加载器、自定义类加载器。
双亲委派机制：当一个类加载器接收到类加载任务时，会先交给其父类加载器去完成，因此所有的加载请求都会传送到启动类加载器中，只有当父类加载器无法完成加载请求时，子类加载器才会尝试自己去加载。
双亲委派机制可以防止内存中出现多份同样的字节码。在JVM中表示两个class对象是否为同一个类有以下几个条件：
1. 类的完整类名必须一致，包括包名。也就是说，即使两个类来源于同一个Class文件，被同一个虚拟机加载，但只要加载它们的类加载器不同，那这两个类就必定不相等。
2. 使用同一个类加载器对同一个class文件进行多次加载，得到的Class对象是相同的。
3. 通过ClassLoader的loadClass(String)方法加载的Class对象，不会显示地使用父类加载器加载，但通过Classloader的findClass(String)方法加载的Class对象，可以使用指定类加载器加载。



什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。
Java虚拟机让这个变为可能，因为它知道底层硬件平台的 指令长度和其他特性。

说说JVM相关的类的加载、链接和初始化的问题？
一个Java类从字节代码到能够在JVM中被使用，需要经过加载、链接和初始化这三个步骤。这三个步骤中，对开发人员直接可见的是Java类的加 载，通过使用Java类加载器（class loader）可以在运行时刻动态的加载一个Java类；
链接和初始化对开发人员直接可见 不直接可见，因为：链接和初始化是在使用Java类之前会发生的动作


常用的JVM启动参数有哪些?
# JVM启动参数不换行
# 设置堆内存
-Xmx4g -Xms4g
# 指定GC算法
-XX:+UseG1GC -XX:MaxGCPauseMillis=50
# 指定GC并行线程数
-XX:ParallelGCThreads=4
# 打印GC日志
-XX:+PrintGCDetails -XX:+PrintGCDateStamps
# 指定GC日志文件
-Xloggc:gc.log
# 指定Meta区的最大值
-XX:MaxMetaspaceSize=2g
# 设置单个线程栈的大小
-Xss1m
# 指定堆内存溢出时自动进行Dump
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/usr/local/
# 指定默认的连接超时时间
-Dsun.net.client.defaultConnectTimeout=2000
-Dsun.net.client.defaultReadTimeout=2000
# 指定时区
-Duser.timezone=GMT+08
# 设置默认的文件编码为UTF-8
-Dfile.encoding=UTF-8
# 指定随机数熵源(Entropy Source)
-Djava.security.egd=file:/dev/./urandom

-Xms2g：初始化推大小为 2g；
-Xmx2g：堆最大内存为 2g；
-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
private String secureRandomAlgorithm = "SHA1PRNG";
-Djava.security.egd=file:/dev/./urandom
-XX:+PrintGC：开启打印 gc 信息；
-XX:+PrintGCDetails：打印 gc 详细信息。

 堆栈配置相关  java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0
-Xmx3550m： 最大堆大小为3550m。
-Xms3550m： 设置初始堆大小为3550m。
-Xmn2g： 设置年轻代大小为2g。
-Xss128k： 每个线程的堆栈大小为128k。
-XX:MaxPermSize： 设置永久代大小为16m
-XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去永久代）。
-XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。

 垃圾收集器相关  -XX:+UseParallelGC-XX:ParallelGCThreads=20-XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5-XX:+UseCMSCompactAtFullCollection：
-XX:+UseParallelGC： 选择垃圾收集器为并行收集器。
-XX:ParallelGCThreads=20： 配置并行收集器的线程数
-XX:+UseConcMarkSweepGC： 设置年老代为并发收集。
-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。
-XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片

辅助信息相关  -XX:+PrintGC-XX:+PrintGCDetails


说一下 JVM 调优的工具?
JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款可视化工具。 第三方有：MAT(Memory  AnalyzerTool)、GChisto。
jconsole：用于监控 HotSpot 进程的轻量级工具，它的功能比较简单，可以用来监控内存、线程、类加载情况等。
jvisualvm：是一个功能强大的多合一故障诊断和性能监控工具。它提供了全面的运行时环境信息，并可以监控应用程序的内存、线程、CPU、类加载、VM 参数等信息。
MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的 Javaheap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗
GChisto，一款专业分析gc日志的工具

JVM调优连环炮：调优命令有哪些？

Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo
1. jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
2. jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
3. jmap，JVM Memory Map命令用于生成heap dump文件
4. jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看
5. jstack，用于生成java虚拟机当前时刻的线程快照。
6. jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数




设置堆内存XMX应该考虑哪些因素？
需要根据系统的配置来确定，要给操作系统和JVM本身留下一定的剩余空间。推荐配置系统或容器里可用内存的 70 -80% 最好

假设物理内存是8G，设置多大堆内存比较合适?
比如说系统有 8G 物理内存，系统自己可能会用掉一点，大概还有 7.5G 可以用，那么建议配置 ‐Xmx6
说明：
7.5G*0.8 = 6G
如果知道系统里有明确使用堆外内存的地方，还需要进一步降低这个值



XM设置的值与JVM进程所占用的内存有什么关系?
JVM总内存=栈+堆+非堆+直接内存+Native
整个堆大小=年轻代大小 + 年老代大小 + 永久代大小.

怎样开启GC日志？
jdk8及以下
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:gc.log 

jdk9及以上
-# JDK 11 环境，输出 info 级别的 GC 日志
java -Xms512m -Xmx512m
-Xlog:gc*=info:file=gc.log:time:filecount=0
demo.jvm0204.GCLogAnalysis


怎么打出线程栈信息。
输入jps，获得进程号。
top -Hp pid 获取本进程中所有线程的CPU耗时性能
jstack pid命令查看当前java进程的堆栈状态
或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。
可以使用fastthread 堆栈定位，fastthread.io/


请指定使用G1垃圾收集器来启动 程序
java ‐XX:+UseG1GC
‐Xms4g
‐Xmx4g
‐Xloggc:gc.log
‐XX:+PrintGCDetails
‐XX:+PrintGCDateStamps Hello


Java8默认使用的垃圾收集器是什么?
Java 8的默认垃圾回收器是Parallel Scavenge（用于新生代）和Parallel Old（用于老年代）
并行垃圾收集器（Parallel GC）。

Java11的默认垃圾收集器是什么?
Java9之后，官方JDK默认使用的垃圾收集器是G1




常见的垃圾收集器有哪些?
常见的垃圾收集器包括：
串行垃圾收集器： ‐XX:+UseSerialGC
并行垃圾收集器： ‐XX:+UseParallelGC
CMS垃圾收集器：‐XX:+UseConcMarkSweepG
G1垃圾收集器： ‐XX:+UseG1GC


什么是串行垃圾收集?
 就是只有单个worker工作线程来执行GC工作。


什么是并行垃圾收集?
并行垃圾收集，是指使用多个GC worker 线程并行地执行垃圾收集，能充分利用多核CPU的能力，缩短垃圾收集的暂停时间。
除了单线程的GC，其他的垃圾收集器，比如 PS，CMS， G1等新的垃圾收集器都使用了多个线程来并行执行GC工作

什么是并发垃圾收集器?
并发垃圾收集器，是指在应用程序在正常执行时，有一部分GC任务，由GC线程在应用线程一起并发执行。
例如 CMS/G1的各种并发阶段

什么是增量式垃圾收集?
首先， G1的堆内存不再单纯划分为年轻代和老年代，而是划分为多个（通常是 2048个）可以存放对象的小块堆区域（smaller heap regions）。
每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor 区或者 Old 区。这样划分之后，使得 G1 不必每次都去回收整个堆空间，而是以增量的方式来进行处理： 每次只处理一部分内存块，称为此次 GC 的回收集（collection set）。
下一次GC时在本次的基础上，再选定一定的区域来进行回收。增量式垃圾收集的好处是大大降低了单次GC暂停的时间。

什么是年轻代？
年轻代是分来垃圾收集算法中的一个概念，相对于老年代而言，年轻代一般包括：新生代，Eden区。
存活区，执行年轻代GC时，用存活区来保存活下来的对象。
存活区也是年轻代的一部分，但一般有2个存活区，所以可以来回倒腾。


什么是GC停顿(GC pause)?
GC停顿，是指应用程序在执行GC时，会暂停所有的工作线程，等待GC完成。
GC停顿时间，就是指应用程序暂停的时间。
因为GC过程中，有一部分操作需要等所有应用线程都到达安全点，暂停之后才能执行，这时候就叫做GC停顿，或者叫做GC暂停。

GC停顿与STW停顿有什么区别？
这两者一般可以认为就是同一个意思




如果CPU使用率突然飙升，你会怎么排查？
1. 使用top命令查看当前CPU使用率最高的进程。
2. 使用top -Hp命令查看当前进程中各个线程的CPU使用率。
3. 使用jstack命令查看当前线程的堆栈信息，找出CPU使用率最高的线程。
4. 使用jmap命令查看当前堆内存的使用情况，找出内存泄漏的线程。

free -h 查看内存使用情况

分析应用日志
分析GC日志
获取线程转储并分析
获取堆转储来进行分析


什么是逃逸分析
逃逸分析，是一种编译器优化技术，用于判断对象的作用域是否超出了方法或线程。
逃逸分析的作用是，如果一个对象在方法内部被创建，并且没有逃逸出方法，那么这个对象就可以在栈上分配，而不是在堆上分配。这样可以减少垃圾回收器的负担，提高程序的性能。

       答：逃逸分析是JVM的一种优化技术，它分析对象的作用域和生命周期，如果确定对象不会被其他线程访问，那么它可以在栈上分配，而不是在堆上，这样可以减少垃圾收集器的工作量。

Java中的对象一定是在堆上分配的吗？
不一定，Java中的对象可以在堆上分配，也可以在栈上分配。具体取决于对象的作用域和生命周期。如果对象的作用域超出了方法或线程，那么这个对象就会在堆上分配，否则就会在栈上分配。一般情况下JVM运行时的数据都是存在栈和堆上的。
答：不一定。
如果满足了逃逸分析的条件，一个对象，完全可以在栈上分配。减少堆内存的分配和GC压力。由于栈内存有限，所以， 如果对象符合标量替换的条件，进一步为对象来一次化整为零的手术
标量替换具体的做法是：JVM会将对象进一步打散，将对象分解为若干个被这个方法使用的成员变量，从而，达到更好的利用栈内存和寄存器的目标


栈用来存放一些基本变量和对象的引用，
堆用来存放数组和对象，也就是说new出来的实例。

随着JIT编译器的发展和逃逸分析的技术成熟，栈上分配、标量替换等优化技术，使对象不一定全都分配在堆中。
在JVM的实现中，为了提高JVM的性能和节省内存空间，JVM提供了一种叫做 “逃逸分析” 的特性，逃逸分析是目前Java虚拟机中比较前沿的优化技术，也是JIT中一个很重要的优化技术。

“逃逸分析” 的本质：
主要就是分析对象的动态作用域，分析一个对象的动态作用域是否会逃逸出方法范围、或者线程范围。

如果一个对象在一个方法内定义，如果被方法外部的引用所指向，那认为它逃逸了。 否者，这个对象，没有发生逃逸。

逃逸分析就是：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。在JVM的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。
即时编译判断对象是否逃逸的依据：
一种是对象是否被存入堆中（静态字段或者堆中对象的实例字段），另一种就是对象是否被传入未知代码。



逃逸分析的类型有两种：
方法逃逸
线程逃逸

什么是：方法逃逸(对象逃出当前方法)：
当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中。
什么是：线程逃逸((对象逃出当前线程)：
这个对象甚至可能被其它线程访问到，例如赋值给类变量或可以在其它线程中访问的实例变量









逃逸分析后的代码优化
从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），
则可能为这个对象实例采取不同程度的优化。通过逃逸分析，编译器会对代码进行优化。
如果能够证明一个对象不会逃逸到方法外或者线程外，或者说逃逸程度比较低，则可以对这个对象采用不同程度的优化：
栈上分配
标量替换
消除同步锁

锁消除：当一个锁对象只被一个线程加锁时，即时编译器会把锁去掉
栈上分配：当一个对象没有逃逸时，会将对象直接分配在栈上，随着线程回收，由于JVM的大量代码都是堆分配，所以目前JVM不支持栈上分配，而是采用标量替换
标量替换：当一个对象没有逃逸时，会将当前对象打散成若干局部变量，并分配在虚拟机栈的局部变量表中


栈上分配
对象不分配在堆上，而是分配在栈内存上。前提是：对象没有逃逸，很老实的话。
具体而言：
完全不会逃逸的局部变量和不会逃逸出的线程对象，采用栈上分配，对于发生逃逸的、不老实的对象，才使用 堆上分配。
栈上分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。

同步锁消除
-XX:+EliminateLocks
-XX:+DoEscapeAnalysis

逃逸分析相关JVM参数

-XX:+DoEscapeAnalysis 开启逃逸分析
-XX:+PrintEscapeAnalysis 开启逃逸分析后，可通过此参数查看分析结果。
-XX:+EliminateAllocations 开启标量替换
-XX:+EliminateLocks 开启同步消除
-XX:+PrintEliminateAllocations 开启标量替换后，查看标量替换情况。








什么是即时编译？
即时编译，是一种在运行时将字节码编译成本地机器码的技术。JVM在运行时，会将字节码编译成本地机器码，然后直接运行本地机器码，从而提高程序的运行效率。
即时编译是一种动态编译技术，它可以在运行时将字节码编译成本地机器码，从而提高程序的运行效率。即时编译是一种动态编译技术，它可以在运行时将
1.1、前端编译
编译器（javac）将源文件（.java）编译成java字节码文件（.class）的步骤是前端编译。
1.2、解释执行
在JVM加载字节码后，每次执行方法调用时，JVM都会将字节码翻译成机器码，然后执行机器码，这个过程叫解释执行。解释执行为了提升启动效率，并没有在启动时将字节码全部翻译成机器码，所以启动效率较高
 但是，由于字节码不行执行，要机器码才能执行，所以，执行时要进行字节码翻译，所以执行效率相对较低
1.3、编译执行
什么是编译执行？
与解释执行相反，JVM加载字节码的时候，直接将字节码转换为机器码，在执行方法调用时直接执行机器码，不需要做翻译工作，这样的过程叫编译执行。
编译执行的问题是什么呢？
和解释执行相反，编译执行在启动时将字节码全部翻译成机器码，所以启动效率较低但是编译执行时省去了翻译的步骤，所以执行效率相对较高


即时编译
解释执行的特点是：启动效率高、执行效率低
编译执行的特点是：启动效率低、执行效率高
JVM如何实现双高呢？实现，启动效率高、执行效率也高。

如何平衡启动速度和执行的速度
为了平衡启动和执行的效率，JVM结合解释执行和编译执行的特点，进行综合和平衡，形成了一种折中的性能优化策略。JVM以解释执行，编译执行为辅，达到启动速度和执行速度的最优化。
那些代码需要编译执行呢？热点代码。
JVM 并不对全部代码进行编译执行，仅仅对热点代码进行编译优化，这样的执行过程叫即时编译

什么是“热点代码”（Hot Spot Code)？
热点代码，就是被频繁执行的方法。JVM会通过一个计数器来统计方法的执行次数，当方法的执行次数超过一定阈值时，JVM就会将这个方法编译成机器码，然后执行机器码，从而提高程序的运行效率。
当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。
把翻译后的机器码缓存在哪里呢？ 这个 机器码缓存，叫做 Code Cache。当JVM下次遇到相同的热点代码时，跳过解释的中间环节，直接从 Code Cache加载机器码，直接执行，无需 再编译。
所以，JIT总的目标是发现热点代码， 热点代码变成了提升性能的关键，Java官方给自家开源的JVM取字为hotspot JVM，也就是这么来的。说得更大白话一点，Java官方把识别“热点代码”（Hot Spot Code)这个任务，写在名字上，作为毕生的追求。
所以，JVM总的策略为：
对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；
另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，并且缓存起来，后面省略编译的过程，直接从缓存当中取得机器码，从而以达到理想的运行速度。

JVM如何实现“热点代码”的编译执行？
JVM通过一个计数器来统计方法的执行次数，当方法的执行次数超过一定阈值时，JVM就会将这个方法编译成机器码，然后执行机器码，从而提高程序的运行效率。



高并发WEB三级缓存架构里边，有hotkey和本地高速缓存
JVM架构里边有Hot Spot和 Code Cache


即时编译器
JVM包含多个即时编译器，主要有C1和C2，还有个Graal (实验性的)。 多个即时编译器, 都会对字节码进行优化并生成机器码。
但是不同的即时编译器，优化的程度不同：C1会对字节码进行简单可靠的优化，C2会对字节码进行激进优化。
C1会对字节码进行简单可靠的优化，包括方法内联、去虚拟化、冗余消除等，编译速度较快，可以通过-client强制指定C1编译
C2会对字节码进行激进优化，包括分支频率预测、同步擦除等，可以通过-server强制指定C2编译如果没有强制指定，JVM默认会使用分层编译模式。
如果没有强制指定，JVM默认会使用分层编译模式。

分层编译模式
JVM不会直接启用C2，而是先通过C1编译收集程序的运行状态，再根据分析结果判断是否启用C2。
分层编译模式下, 虚拟机执行状态由简到繁、由快到慢分为5层
0 层，解释执行（Interpreter）
1 层，使用 C1 即时编译器编译执行，无profiling
2 层，使用 C1 即时编译器编译执行，带基本的 profiling（仅方法调用次数及循环回边执行次数的profiling）
3 层，使用 C1 即时编译器编译执行，带完全的 profiling
4 层，使用 C2 即时编译器编译执行

什么是JVM的分层编译（Tiered Compilation）？

答：分层编译是一种编译策略，它将代码编译分为多个层次，从解释执行到优化编译。这样可以在程序启动时快速执行代码，然后在运行时根据代码的热度逐渐应用更高级的优化

什么是profiling ?
profiling是C0/C1在编译过程中收集程序执行状态的过程 收集的执行状态记录为profile (概述/ 印象)，包括分支跳转频率、是否出现过空值和异常等，主要用于触发C2编译。

OOM后，JVM一定会退出吗？为什么？
不一定，JVM在发生OOM后，不一定一定会退出。JVM在发生OOM后，会尝试进行垃圾回收，如果垃圾回收后，仍然无法释放足够的内存，那么JVM就会抛出OutOfMemoryError异常，但是JVM并不会立即退出，而是会尝试进行一次最后的努力，尝试释放一些内存
，如果仍然无法释放足够的内存，那么JVM就会退出。

OutOfMemoryError 也只是一个java中的异常而已， OutOfMemoryError 属于Error一系非检查异常， 其继承关系如下
Object
    Throwable
        Error
            VirtualMachineError
                OutOfMemoryError

线程发生OutOfMemoryError，首先是堆空间不够了，然后再由jvm在申请分配空间的的时候，在调用上抛出OOM异常。
申请内存的线程，会像处理普通的其他异常一样，处理OutOfMemoryError。
线程是资源调度的基本单位，Java在设计线程时充分考虑了线程的独立性。
在异常方面，线程也保持了线程异常的独立性。
在线程执行中，如果发生的异常，都由线程进行独立的处理，而不是也不会抛出到其它的线程。这就是保证了这种线程的独立性
线程方法执行中发生的任何检查异常，必须在线程中处理

线程拿到异常，有两种处理方式：
捕获并且处理异常，线程继续执行
线程停止执行

OutOfMemoryError 是一个Error，Error是Throwable的子类，Error是程序无法处理的错误，一旦出现这个错误，程序将无法继续运行，JVM会选择终止程序。

默认异常处理器
如果没有被捕获除了检查异常，java中还有非检查异常（unchecked exception），这种异常无需显式声明也能沿着方调用链向上抛出。
线程对于这种未处理的异常，提供了默认异常处理器

/**
* Dispatch an uncaught exception to the handler. This method is
* intended to be called only by the JVM. (将未被捕获的异常分发给处理器。这个方法只被JVM调用)
*/
private void dispatchUncaughtException(Throwable e) {
    getUncaughtExceptionHandler().uncaughtException(this, e);
}
Thread的init()方法线程至少有一个默认异常处理器，兜底的异常处理器是当前线程父线程的线程组ThreadGroup，可以看到线程组是有能力处理异常的
public class ThreadGroup implements Thread.UncaughtExceptionHandler {}
线程通过这两种机制，保证内部发生的异常，在线程内解决，而不会抛出给启动线程的外部线程。


JVM退出条件
JVM 不存在非守护线程（前台线程），JVM就会退出
线程发生未处理的异常（未处理异常由默认异常处理器处理）会导致线程结束，而线程结束了， 如果还有非守护线程（前台线程），JVM也不会退出。
OOM也是一种异常，它的发生也不会导致JVM退出。
所以，OOM 与JVM的退出，没有很强的关系

线程中发生OOM异常，和发生其他异常一样，只是那个线程终止了，但是不影响其他线程，thread-0 线程线程OOM，也不会导致JVM退出。

OOM与JVM退出的关系
什么时候发生OOM、JVM才退出呢？
场景1：所有的非守护线程由于申请不到内存而OOM，所有非守护线程退出，JVM退出，这个属于主动退出的退出。

OOM的发生表示了此刻JVM堆内存告罄，不能分配出更多的资源，或者GC回收效率不可观。
一个线程的OOM，在一定程度的并发下，若此时其他线程（含非守护线程）也需要申请堆内存，那么其他线程也会因为申请不到内存而OOM，甚至连锁反应导致整个JVM
场景1：OOM溢出，说明内存耗尽，如果操作系统内存耗尽，就会发生OOM killer(Out Of Memory killer)，干掉JVM进程，导致被动退出
Linux 内核有个机制叫OOM killer(Out Of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用内存很快的进程，然后防止内存耗尽而自动把该进程杀掉。
内核检测到系统内存不足、挑选并杀掉某个进程的过程可以参考内核源代码linux/mm/oom_kill.c，当系统内存不足的时候，out_of_memory()被触发，然后调用select_bad_process()选择一个”bad”进程杀掉。
如何判断和选择一个”bad进程呢？
linux选择”bad”进程是通过调用oom_badness()，挑选的算法和想法都很简单很朴实：最bad的那个进程就是那个最占用内存的进程。



什么是指针碰撞？
指针碰撞是一种简单高效的内存分配策略，常用于管理内存堆中的空闲空间，适合处理连续内存分配。

在使用指针碰撞的内存分配中，维护一个指针（通常称为 “分配指针”），指向堆内存中当前可用于分配的第一个位置。当需要分配内存时，只需要进行以下步骤：

检查足够的空间：首先检查从分配指针开始的内存块是否足够大以满足内存分配请求。
分配内存：如果有足够的空间，将内存从分配指针指向的位置开始分配给对象。
移动指针：分配后，将分配指针“碰撞”向前移动到新分配的内存块之后的位置。
指针碰撞内存分配策略非常快，因为它只是简单地移动一个指针，而不需要遍历和查找足够大小的空闲块。然而，它的一个主要缺点是可能会导致内存碎片，特别是在频繁的对象创建和销毁的情况下。
为了解决这个问题，通常会结合使用垃圾收集器，特别是那些采用复制（Copying）或标记-整理（Mark-Compact）算法的收集器，来定期整理内存，减少碎片，从而为指针碰撞策略提供连续的空闲内存区域。



什么是空闲列表？
空闲列表是另一种内存管理方法，用于跟踪堆内存中的空闲空间。与指针碰撞方法不同，空闲列表方法适用于非连续的内存分配。

在使用空闲列表管理内存时，系统会维护一个列表，记录堆内存中所有未被分配的空间。这个列表包含了多个空闲块的大小和位置信息。当应用程序请求分配内存时，内存管理器会遍历空闲列表，寻找一个足够大的空闲块来满足这个请求。

工作流程如下：

查找合适的空闲块：当请求内存分配时，系统会检查空闲列表，查找一个足够大的空闲块。这个查找过程可能会根据不同的策略进行，如首次适应（First Fit）、最佳适应（Best Fit）或最差适应（Worst Fit）。
分配内存：一旦找到合适的空闲块，系统会从这个块中分配所需的内存给请求者。如果空闲块的大小刚好等于请求的大小，则整个块被分配。如果空闲块比请求的大小大，它会被分割，一部分分配给请求者，剩余的部分仍然保留在空闲列表中。
更新空闲列表：分配内存后，空闲列表需要更新以反映内存的新状态。如果一个空闲块被完全使用，它将从空闲列表中移除。如果一个空闲块被分割，列表将更新为只包含剩余部分的信息。
空闲列表方法可以减少内存碎片问题，因为它可以更精细地管理内存分配，但这种精细度带来的代价是更高的管理成本，因为系统必须维护更复杂的数据结构，并且在每次内存分配时进行更多的计算。此外，频繁的分配和回收可能会导致列表变得很长，增加查找合适空闲块的时间。为了优化性能，可以使用合并邻近的空闲块的技术来减少列表的长度和提高内存的利用率。




 JVM 里 new 对象时，堆会发生抢占吗？JVM 是怎么设计来保证线程安全的？
 会。假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。

 有两种可选方案来解决这个问题：

 采用 CAS 分配重试的方式来保证更新操作的原子性。这意味着当一个线程在执行一个原子操作分配内存时，没有其他线程可以同时执行另一个会干扰它的操作。
 线程本地分配缓冲（TLAB）
 JVM 中的每个线程可以拥有自己的小块私有的内存缓冲区，称为线程本地分配缓冲（TLAB）。
 每个线程在自己的 TLAB 上分配内存，这样它们就不会与其他线程冲突，从而减少了同步的需要。
 当一个线程的 TLAB 用尽时，它需要获取新的 TLAB，这个过程可能需要同步，但这种情况发生得比较少。

 什么是JVM的TLAB（Thread Local Allocation Buffer）？

 答：TLAB是每个线程私有的内存区域，用于存储对象分配。当线程进行对象分配时，首先尝试在TLAB中分配内存，这样可以减少垃圾收集器的开销，因为它减少了内存碎片和并发访问。

内存溢出和内存泄漏是什么意思
内存溢出:

内存溢出发生时，表示 Java 虚拟机（JVM）中的堆内存不足，无法再分配新的对象。
这种情况通常发生在应用程序尝试创建对象，但是堆内存已经满了，而且垃圾收集器无法释放任何更多的内存空间。
内存溢出可能是由于内存泄漏，或者是因为 JVM 的堆内存设置不足以应对应用程序的需求。
当内存溢出发生时，JVM 会抛出 OutOfMemoryError 异常。
内存泄漏:

内存泄漏是指已分配的内存资源未能被释放，而应用程序不再使用这些内存资源。
在 Java 中，内存泄漏通常是由于长时间生存的对象持有对不再需要的对象的引用，阻止垃圾收集器回收它们，导致无法回收的对象逐渐积累。
随着时间的推移，内存泄漏会导致可用内存逐渐减少，最终可能导致内存溢出。
内存泄漏的诊断通常需要借助分析工具（如MAT）来检查哪些对象被错误地保留在内存中。
总结来说，内存溢出是指没有足够的内存空间来分配新的对象，通常是一种严重的错误，会导致程序崩溃。而内存泄漏是一个渐进的过程，未使用的对象逐渐积累，消耗掉所有可用内存，可能最终导致内存溢出。

内存泄漏可能由哪些原因导致呢？
内存泄露主要是由于对象不再需要，但是垃圾收集器无法进行回收，因为仍然存在对这些对象的引用。
长生命周期对象持有短生命周期对象的引用：
如果一个具有长生命周期的对象引用了应该是短生命周期的对象，那么这些短生命周期的对象不会被回收。
集合类中的对象没有被及时清理：
在使用集合类（如 List、Map、Set 等）时，即使对象已经不再需要，如果没有从集合中移除，它们就会一直占用内存。
静态字段：
静态字段的生命周期与类的生命周期相同，如果静态字段引用了某个对象，那么这个对象可能在整个应用程序的生命周期内都不会被回收。
内部类和匿名类持有外部类的引用：
非静态内部类和匿名类隐式持有对其外部类实例的引用，如果内部类的实例比外部类活得更久，那么外部类实例也不会被回收。
缓存对象：
未正确管理的缓存可能导致已缓存的对象长时间占用内存，尤其是在使用强引用缓存时。
不当的资源管理：
如果资源（如数据库连接、网络连接等）没有被正确关闭，可能导致内存泄漏。
ThreadLocal变量滥用：
ThreadLocal 变量存储在线程的内存中，如果线程一直运行（例如，在线程池中），那么这些变量可能不会被清理。

finalize()方法了解吗？有什么作用？
finalize()主要用于在对象被垃圾回收器销毁之前执行清理操作。它是 Object 类的一个方法，因此每个类都可以覆盖finalize() 方法来实现自定义的清理逻辑。其作用有如下几个：
资源释放：finalize() 方法通常用于释放对象持有的资源，如关闭文件句柄、网络连接或者释放自定义的内存资源等。这在 Java 早期版本中是一种常见的模式。
最终机会清理：在对象被垃圾回收之前，finalize() 提供了一个最后的机会来执行清理操作。这意味着你可以在对象不再被使用时执行一些重要的清理工作。
但是，由于 finalize() 的调用时机完全取决于垃圾回收器，导致它不可预测性和性能问题，所以已经不再被推荐使用。且在 Java 9 及以后的版本中，finalize() 方法被标记为废弃（deprecated）。



Java 堆的内存分区了解吗？
年轻代（Young Generation）:
这是新创建的对象首先分配内存的地方。年轻代内存分为几个部分：
Eden 空间：大部分新生成的对象首先在 Eden 空间分配。
两个幸存者空间（Survivor Spaces）：分为 S0（Survivor 1）和 S1（Survivor 2）。存活下来的对象从 Eden 空间转移到一个幸存者空间，然后在幸存者空间之间来回移动。
年轻代的特点是对象的分配和回收都相对较快。
老年代（Old Generation 或 Tenured Generation）:
存放长时间存活的对象。
当对象在年轻代中存活足够长的时间后，它们就会被转移到老年代。
老年代的垃圾回收（GC）频率比年轻代低，但每次回收的时间更长。
永久代/元空间（PermGen/Metaspace，取决于 JVM 版本）:
在 JDK 8 之前，JVM 使用的是永久代（PermGen）。永久代主要用于存储类元数据、方法对象等。
由于永久代经常出现内存溢出的问题，JDK 8 引入了元空间（Metaspace）来替代永久代。元空间不在虚拟机内存中而是使用本地内存，因此其大小受本地内存限制。



知道内存分配策略吗？
对象优先在 Eden 分配
在大多数情况下，对象首先在新生代的 Eden 区域分配。当 Eden 区域填满时，会触发 Minor GC（即新生代垃圾回收）。
大对象直接进入老年代
大对象（如大数组或大对象）可能直接在老年代分配内存，以避免在 Eden 区和两个 Survivor 区之间来回复制，减少垃圾回收时的开销。
长期存活的对象将进入老年代
对象在新生代中每经历一次 Minor GC，其年龄就会增加1。当对象的年龄增加到一定程度（默认为 15，可通过 -XX:MaxTenuringThreshold 设置），它们就会被移动到老年代。
这个机制减少了在新生代和老年代之间不必要的对象复制。
动态对象年龄判定
为了更有效地利用内存，JVM 会动态地调整对象晋升到老年代的年龄阈值。
如果在 Survivor 空间中相同年龄所有对象大小的总和超过 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到 -XX:MaxTenuringThreshold 设置的年龄。
空间分配担保
在发生 Minor GC 之前，JVM会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果这个条件满足，那么 Minor GC 是安全的。如果不满足，VM 会查看 -XX:HandlePromotionFailure 设置，决定是否进行一次 Full GC。

为什么 Java 8 使用元空间替代永久代作为方法区的实现？
有如下几个原因：
内存限制问题
永久代内存限制：在旧版本的 JVM 中，永久代的大小是固定的，且在 JVM 启动时就被确定。这意味着存储在永久代中的类元数据的总量受到限制，容易出现 OutOfMemoryError。
元空间更灵活：元空间使用本地内存，而不是虚拟机内存，因此不受 Java 堆大小的限制。这使得元空间可以动态调整大小，减少了内存溢出的风险。
垃圾回收的简化
永久代的回收复杂性：永久代的垃圾回收相对复杂，特别是类和类加载器的卸载机制。
元空间的垃圾回收：将类元数据移到本地内存中的元空间简化了垃圾回收过程，因为元空间主要涉及类元数据的回收，而这通常是在类加载器的生命周期结束时发生。

解释JVM中的Stop-The-World事件?

答：Stop-The-World事件是指在执行垃圾收集或类加载等操作时，JVM会暂停所有应用线程的执行。这种暂停对性能有影响，因为它阻止了程序在这段时间内进行任何工作。

什么是 Stop The World ? 什么是 OopMap ？什么是安全点？
Stop-The-World（STW）
定义：Stop-The-World 指的是在垃圾回收过程中，JVM 会暂停应用程序的所有线程。在这段时间里，除了垃圾回收线程之外，所有线程都会被暂停，不进行任何工作。
目的：STW 事件发生是为了防止应用程序在垃圾回收过程中继续修改对象，这样可以保证垃圾回收的准确性和安全性。
影响：STW 会影响应用程序的响应时间和吞吐量。因此，选择垃圾回收器时，需要考虑其 STW 的时间和频率，以适应不同的应用需求。
OopMap（Ordinary Object Pointer Map）



定义：OopMap 是一种数据结构，它用于记录对象内部哪些部分是指向其他对象的引用（即 Ordinary Object Pointers）。
用途：在垃圾回收过程中，JVM 需要知道堆栈和寄存器中哪些位置存储了指向堆上对象的引用。OopMap 提供了这些信息，使得垃圾回收器可以正确识别这些引用，以更新它们（如果对象被移动了）或者判断对象是否可达。
效率：OopMap 提高了垃圾回收的效率，因为垃圾回收器不需要扫描整个对象来查找引用。
安全点（Safepoint）

定义：安全点是程序执行中的特定位置，在这些位置上，JVM 可以安全地进行垃圾回收。
特征：在安全点，所有引用的位置都是已知的（例如，在方法调用、循环跳转、异常抛出等位置）。这意味着 JVM 可以确保在这些点上的对象引用信息是准确和一致的。
STW 和安全点：Stop-The-World 事件通常在安全点发生，因为这是执行垃圾回收操作的安全时机。
线程同步：为了达到安全点，JVM 会通知所有线程，在它们达到最近的安全点时暂停执行。
对象一定分配在堆中吗？有没有了解逃逸分析技术？
在 Java 中，传统上对象是分配在堆（Heap）内存中的。然而，并非所有对象都必须分配在堆上。Java 虚拟机（JVM）的一个优化技术，称为逃逸分析（Escape Analysis），可以改变这种分配方式。

逃逸分析
逃逸分析是一种编译器优化技术，用于分析对象的作用域和生命周期：

定义：逃逸分析确定对象的使用范围和生命周期是否超出了其定义的作用域。
不逃逸的对象：如果一个对象在方法内创建，并且其引用不会逃逸到方法之外，那么这个对象被认为是“不逃逸”的。
栈分配：对于不逃逸的对象，JVM 可以选择在栈上分配这些对象，而不是在堆上。栈上分配的好处是，一旦方法执行完毕，这些对象的内存就可以立即被回收，从而减少垃圾回收的负担。
同步省略：逃逸分析还可以用于同步省略（也称为锁消除）。如果确定某个对象只能被一个线程访问，那么对这个对象的同步操作可以被省略。
标量替换：逃逸分析还可以进行标量替换，将一个聚合对象拆分成几个独立的局部变量，进一步优化性能。
逃逸分析通常是默认启用的。但是，你也可以通过 JVM 参数显式地开启或关闭它：

启用逃逸分析：-XX:+DoEscapeAnalysis
禁用逃逸分析：-XX:-DoEscapeAnalysis

.解释JVM中的逃逸分析（Escape Analysis）是什么，以及它如何影响性能?

答：逃逸分析是一种代码优化技术，用于分析对象的生命周期。如果一个对象只在被分配的线程中被引用，那么它可以在栈上分配，而不是在堆上。这可以减少垃圾收集器的工作量，因为这些对象可以直接在线程结束时被回收


GC是什么？为什么要GC
GC，即Garbage Collection，垃圾回收，用于自动管理内存。它的主要目的是识别和回收程序不再使用的内存，即“垃圾”，以避免内存泄漏和优化内存使用效率。
为什么需要垃圾回收
自动内存管理：在 Java 这样的高级语言中，程序员不需要显式地分配和释放内存，这是由 JVM 的垃圾回收器自动完成的。这大大简化了编程，减少了内存泄漏和其他内存相关错误的风险。
提高效率：GC 自动回收不再使用的对象，释放内存空间供新对象使用，从而提高了内存的使用效率。
程序稳定性：通过及时清理无用对象，GC 有助于维护应用程序的性能稳定性，避免因内存耗尽导致的程序崩溃。
提高安全性：自动垃圾回收减少了手动内存管理可能带来的安全问题，如悬空指针和重复释放等。
有什么办法主动通知虚拟机进行垃圾回收？
有两种方式可以通知 JVM 进行垃圾回收。

System.gc()** 方法**: 这个方法是最常用的请求垃圾回收的方式。当你调用 System.gc() 时，你实际上是在建议虚拟机执行垃圾回收。虚拟机可能会考虑这个建议，并在合适的时候执行垃圾回收。但是，这种方法并不保证虚拟机一定会立即执行垃圾回收，也不保证回收操作的效果。
Runtime.getRuntime().gc()** 方法**: 这个方法的作用与 System.gc() 类似，也是向虚拟机建议执行垃圾回收。它通过获取当前运行时环境的实例来请求垃圾回收。
一般来说我们要谨慎使用这两种方式，以避免不必要的性能损耗。

在Java中，对象什么时候可以被垃圾回收
在 Java 中，对象变成垃圾回收的候选对象，即可被垃圾回收器回收的时机，主要取决于它们的可达性（Reachability）。以下几种情况可以判定为垃圾回收的候选对象：

无引用: 当对象不再有任何活动引用指向它时，它就可以被垃圾回收。这意味着对象在程序中不再可达，比如所有引用该对象的变量都已经超出了其作用域或被设置为 null。
仅有循环引用: 如果一组对象之间相互引用，但这组对象整体上不再被其他活动部分的程序所引用，那么这组对象也可以被垃圾回收。Java 的垃圾回收器能够识别并处理循环引用。
对象所属的类已经被卸载: 如果一个对象的类的 ClassLoader 被垃圾回收，那么这个类的所有实例也可以被回收。这种情况在一些复杂的应用中可能会发生，尤其是在使用了自定义 ClassLoader 的情况下。
终结器（Finalizer）的作用: 如果一个对象覆盖了 finalize() 方法，并且垃圾回收器发现了它，那么在对象被回收前，finalize() 方法会被调用。但这不是判断对象可以被回收的条件，而是在对象回收前的一种机制。因为 finalize() 方法的不确定性和性能问题，一般不推荐使用。
但是，即使对象变成了垃圾回收的候选对象，具体何时被回收仍然是不确定的。垃圾回收的具体时机取决于垃圾回收器的算法和内存使用情况。

JVM中的永久代中会发生垃圾回收吗
从 Java 8 开始，永久代已被元空间（Metaspace）所替代。但是，在 Java 8 之前的版本中，永久代是存在的，并且在永久代中也会发生垃圾回收。
Java 8 之前的版本（使用永久代）
在永久代中，确实会发生垃圾回收，但这种回收发生的频率和情况与堆内存中的垃圾回收有所不同。当类被卸载（这通常发生在使用了自定义类加载器并且该类加载器被回收的情况下）时，该类及其相关的元数据就会从永久代中移除。
在 Java 8 及以后的版本（使用元空间）
在元空间中，类的元数据仍然可以被回收。当类不再被使用时（例如，当类的加载器不再存在时），这些类及其元数据会被垃圾回收器回收。


说一下 JVM 有哪些垃圾回收算法？
标记-清除（Mark-Sweep）算法
此算法分为两个阶段：标记和清除。在标记阶段，算法标记出所有从根集合可达的对象。在清除阶段，未被标记的对象被认为是垃圾，并被清除。
但是，它可能产生大量内存碎片，导致后续可能无法为大对象找到足够的连续内存空间。
复制（Copying）算法
它将可用内存分为两块。每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后清理掉当前使用的这一块内存。
没有内存碎片。但它会使内存使用率低，因为任何时候只有一半的内存是被使用的。
标记-整理（Mark-Compact）算法
此算法在标记阶段和标记-清除算法相似。在整理阶段，它将所有存活的对象压缩到内存的一端，然后清理掉边界以外的内存。
它解决了内存碎片问题。但是整理过程中需要移动对象，可能会有较高的开销。
分代（Generational）收集算法
不同年龄的对象的生命周期不同。通常将内存分为年轻代（Young Generation）和老年代（Old Generation），分别应用不同的回收策略。
通过优化针对不同年龄段的对象的回收策略，可以在提高效率的同时减少回收引起的停顿时间。


能详细说一说G1 收集器吗？
G1（Garbage-First）是被设计用来替代旧的如 CMS（Concurrent Mark-Sweep）收集器。G1 收集器的主要目标是提供高吞吐量同时保持尽可能低的延迟。

工作原理

堆分区：
G1 收集器将堆内存分割成多个大小相等的区域（Region），这些区域可以是 Eden、Survivor 或 Old Generation。
这种划分使得 G1 能够更灵活地管理堆，只回收价值最大的区域，从而控制回收周期的长度。
回收过程：
G1 收集器同时处理 Young 和 Old Generation，用来替代传统的 Young Generation（如 Parallel GC）和 Old Generation（如 CMS）收集器。
G1 通过跟踪每个区域中的垃圾量，优先回收包含最多垃圾的区域，以此提高回收效率。
并发和停顿：
G1 收集器的许多操作是并发进行的。例如，在处理 Old Generation 时，它会并发地标记活动对象。
G1 致力于保持较短的停顿时间，它允许用户指定期望的停顿时间目标（例如，不超过 100ms），并尽量在这个范围内完成回收工作。
特点

可预测的停顿时间：
通过设定期望的停顿时间，G1 能够更好地满足需要低延迟的应用的需求。
高效的垃圾回收：
回收最有价值区域的策略提高了回收效率，尤其是在堆内存较大的情况下。
并发标记：
并发地标记活动对象，减少了全面垃圾回收的需要，从而降低了停顿时间。
碎片整理：
在进行垃圾回收时，G1 还会进行碎片整理，这有助于避免内存碎片化，提高内存分配的效率。
适用场景

G1 特别适合于堆内存较大（超过 4GB）的应用程序。
对于要求较短停顿时间的应用，G1 也是一个很好的选择。
有了 CMS，为什么还要引入 G1？
由于 CMS 对 CPU 资源比较敏感，在垃圾回收的过程还会产生内存碎片。而 G1 旨在填补 CMS 的不足：

更好的性能：G1 提供了更好的性能，尤其是在大内存应用中。它通过划分区域和优先级回收减少了全堆扫描的需要。
内存碎片处理：G1 通过整理来减少内存碎片，这是 CMS 面临的主要问题之一。
可预测的停顿：G1 允许用户指定停顿时间，这对于需要高响应性的应用来说非常重要。
更广泛的适用性：G1 的设计旨在适应更广泛的应用场景，包括那些拥有大量内存和多核处理器的服务器环境。


什么时候会触发FullGC
Full GC 通常比新生代的垃圾回收更耗时，因为它会涉及到整个堆内存的回收活动，包括新生代、老年代以及永久代（或者在 Java 8 及以后版本的元空间 Metaspace）。以下是触发 Full GC 的一些常见情况：

老年代空间不足：当老年代空间不足以为新晋升的对象提供空间时，JVM 会触发 Full GC 来清理老年代并回收更多空间。
新生代晋升到老年代的空间不足：如果在新生代的垃圾回收后，存活的对象空间超过了老年代能提供的空间，JVM 也会触发 Full GC。
永久代（PermGen）或元空间（Metaspace）满：当类的元数据占用的空间超过了永久代或元空间的限制时，JVM 会触发 Full GC。在 Java 8 及以后版本中，元空间取代了永久代。
System.gc() 调用：当应用程序显式调用 System.gc() 时，JVM 通常会执行 Full GC。然而，这个行为并不是完全保证的，因为垃圾回收是由 JVM 控制的。
JVM 内部的垃圾回收算法决定：JVM 的垃圾回收算法可能决定执行 Full GC，例如在某些情况下进行内存压缩或在低内存情况下的资源回收。
RMI 的垃圾回收：在使用 RMI 时，JVM 默认每分钟进行一次 Full GC，以回收 RMI 收集的对象。


Java 中可作为 GC Roots 的对象有哪几种？
本地方法栈中的引用： 这些是从本地方法（即用非 Java 语言编写的方法，如 C 或 C++）引用的对象。
Java 虚拟机栈中的引用： 这包括 Java 方法的局部变量。每个线程的方法调用都有自己的栈帧，其中包含局部变量表，这些局部变量可能引用其他对象。
方法区中的类静态属性引用的对象： 方法区（Method Area）存储了每个类的结构，如运行时常量池、字段、方法数据等。类的静态变量也存储在这里，它们可能引用其他对象。
方法区中常量引用的对象： 这指的是方法区中的常量池中的引用，常量池主要存储编译时期生成的各种字面量和符号引用。
同步锁持有的对象： 在同步代码块或方法中作为锁定对象的引用。

JVM中的类卸载机制是什么？
JVM中的类卸载机制：

1、触发条件： 当一个类的ClassLoader实例被回收，同时该类没有任何活跃的实例，且没有其他地方引用该类的方法或变量时，这个类就会被卸载。

2、回收过程： 类的卸载发生在垃圾收集过程中。

3、重要性： 在使用自定义类加载器频繁加载和卸载类的场景中，类卸载机制特别重要，以避免内存泄漏。

JVM中的引用计数法和可达性分析算法。
JVM中的引用计数法和可达性分析算法：

1、引用计数法： 每个对象有一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1。任何时刻计数器为0的对象可以被回收。

2、可达性分析算法： 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。

3、主流选择： 在主流的JVM实现中，一般采用可达性分析算法来判断对象的存活，因为引用计数法无法解决对象之间相互循环引用的问题。



jdk 和jre的改变
jdk 1.8 以后，jdk和jre合并了。
最大的区别：从jdk9开始删除了JDK和JRE之间的区别，在jdk9中，没有名为jre的目录。

在jdk SE 9 之前，jdk构建系统用于生成两种类型的运行时映射-JRE(java运行时环境)和JDK(java开发工具包)。
JRE 是java SE 平台的完整实现，JDK包含了JRE 和开发工具和类库。


描述一下JVM 加载class 文件的原理机制
JVM 加载 class 文件的原理机制大致分为如下几个关键阶段：

类加载器（Class Loaders）:
类加载是由类加载器（ClassLoader）完成的。JVM 提供了几种内置的类加载器（比如启动类加载器、扩展类加载器和应用类加载器），同时也允许创建自定义的类加载器。
类加载器首先会检查请求的类是否已经被加载。如果已加载，直接返回该类的 Class 对象；如果未加载，进入加载过程。
查找 Class 文件:
类加载器会根据类的全限定名（如 java.lang.String）在文件系统或者其他地方（如网络、ZIP 文件等）查找对应的 .class 文件。
加载 Class 文件:
一旦找到了对应的 Class 文件，类加载器会将该文件的内容（二进制数据）加载到内存中。这些数据包含了类的结构、方法、变量等信息。
解析:
加载到内存中的类数据会被解析成为一个 java.lang.Class 类的实例。这个实例代表了被加载的类，包含了该类的所有信息。
验证:
验证是确保加载的类满足 JVM 规范且不会危害到 JVM 自身安全的一个重要步骤。这包括对类的格式、方法和字段的访问性、以及其他一些基本的结构检查。
准备:
在准备阶段，JVM 会为类中的所有静态变量分配内存，并设置默认初始值。这些默认值通常是数据类型的零值（如 0、false 等）。
解析引用:
这一步涉及将类文件中的符号引用转换为直接引用。符号引用是一种抽象的引用，如类和接口的全限定名，而直接引用通常是指向内存中对象或方法的指针。
初始化:
最后阶段是类的初始化，这时会执行静态初始化器（静态代码块）和静态变量的赋值操作。
类加载器有哪些？
启动类加载器（Bootstrap ClassLoader）:
这是最顶层的类加载器，用于加载 JVM 的核心类库，如 rt.jar 和其他核心库文件。它不是 java.lang.ClassLoader 的子类，因为 JVM 是用原生代码实现的。
扩展类加载器（Extension ClassLoader）:
负责加载 Java 的扩展库，即 JAVA_HOME/jre/lib/ext 目录下的 JAR 包和类文件，或者由系统属性 java.ext.dirs 指定的路径下的类库。
应用类加载器（Application ClassLoader）:
这是用于应用程序级别的类加载器，负责加载环境变量 CLASSPATH 或系统属性 java.class.path 指定路径下的类库。它是 java.lang.ClassLoader 的一个实例，是我们通常使用的默认类加载器。
用户自定义类加载器:
Java 允许开发者通过继承 java.lang.ClassLoader 类来创建自己的类加载器。这使得开发者可以自定义类的加载方式，例如从加密文件中加载类，或者从网络等非标准来源加载。
类加载器之间存在父子关系，但并非通过继承实现，而是通过组合。当一个类加载器收到类加载的请求时，它首先会委托给其父加载器去尝试加载这个类，只有在父加载器加载失败时，它才会尝试自己去加载。这种委托机制确保了 Java 类的唯一性，例如，无论一个应用中有多少个类加载器，java.lang.Object 这个类都只会被加载一次。


什么是双亲委派模型？
双亲委派模型是 Java 中类加载器使用的一种特定机制，用于加载类和接口。

当一个类加载器收到类加载的请求时，它首先不会尝试自己加载这个类，而是把这个请求委派给父类加载器去完成。
这个过程会一直向上递归，直到达到最顶层的启动类加载器（Bootstrap ClassLoader）。
只有当父类加载器无法完成这个请求（即它不支持加载请求的类）时，子类加载器才会尝试自己去加载这个类。
为什么要用双亲委派机制？
保障安全性:
双亲委派机制可以防止基础类库被随意替换。由于系统类由启动类加载器加载，因此即使用户编写了与系统类同名的类，也不会导致系统类被替换，这保护了 Java 核心类库的安全性。
避免类的重复加载:
在双亲委派模型下，类只会被加载一次。当一个类加载器收到类加载的请求时，它会首先尝试让其父类加载器去加载这个类，以此来保证不会加载已经加载过的类。这避免了同一个类被多次加载的情况，节省了资源，同时保持了类的单一性。
保持命名空间的一致性:
双亲委派模型帮助维护了 Java 类的命名空间。不同的类加载器可以定义不同的命名空间，相同名称的类可以存在于不同的类加载器及其命名空间中，而不会发生冲突。
提升性能:
由于类只加载一次，所以减少了类加载的次数，这在一定程度上提高了性能。特别是对于核心类库这种被频繁使用的类，这种优势更加明显。
如何破坏双亲委派机制？
破坏双亲委派机制通常意味着自定义类加载器以改变类加载的顺序或方式。在特定的应用场景中，比如热部署（hot deployment）或插件式架构，可能需要定制类加载过程以满足特殊需求。要破坏双亲委派机制，可以按照以下步骤进行：

自定义类加载器:
继承 java.lang.ClassLoader 类来创建自己的类加载器。
重写 ****loadClass():
在自定义类加载器中重写 loadClass()。通常，loadClass() 方法首先会调用父类加载器尝试加载类，如果失败，再尝试自己加载类。要破坏双亲委派模型，可以改变这个顺序。
直接加载类:
在 loadClass() 方法中，可以先尝试自己加载类，而不是委派给父类加载器。如果自己无法加载，再考虑将请求委派给父类加载器。
使用 ****findClass():
在自定义类加载器中实现 findClass() 方法。当 loadClass() 方法在父类加载器中找不到类时，将会调用 findClass()方法尝试加载类。在 findClass() 方法中，可以实现特定的类加载逻辑。
你知道 Java 中有哪些破坏了双亲委派机制？
在 Java 中，有几个典型的例子破坏了双亲委派机制：


JDBC 4.0 驱动加载

在 JDBC 4.0 中，引入了一种服务提供者机制（SPI），允许 JDBC 驱动程序在 META-INF/services 目录下注册自己，而不需要通过代码显式加载驱动。这种机制实际上破坏了传统的双亲委派模型，因为它允许驱动程序类被应用程序类加载器加载，而不是始终由系统类加载器加载。
Tomcat 容器

Tomcat为每个部署的 Web 应用使用一个单独的类加载器，允许加载与其他应用隔离的类。这样，相同的类（例如，一个常见的库的不同版本）可以存在于不同的 Web 应用中，而不会相互干扰。这种机制破坏了标准的双亲委派模型，因为容器首先尝试使用自己的类加载器加载类，而不是委派给父类加载器。



你觉得应该怎么实现一个热部署功能？
热部署功能是可以在修改完代码后，不重启应用，实现类信息更新，以节省开发时等待启动时间。

在 Java 中，要实现热部署功能通常涉及动态地加载、更新和卸载类或资源。下面实现热部署的基本步骤：

自定义类加载器:

实现一个自定义的类加载器，这个类加载器可以加载或重新加载改变了的类文件。热部署的关键是能够替换旧的类定义，这通常需要破坏标准的双亲委派模型。
类定义的隔离:

保证每个版本的类都被隔离开来，以避免不同版本之间的冲突。这可以通过为每个版本的类创建不同的类加载器实例来实现。
监控类文件的改变:

实现一个机制来监控类文件的改变。这可以通过文件系统监控，或者在开发环境中监听构建系统的输出。
重新加载改变的类:

一旦检测到类文件有改变，使用新的或者专门的类加载器加载新版本的类。旧版本的类需要被垃圾回收，这通常意味着需要切断所有到旧类实例和类加载器的引用。
状态管理:

在类重新加载时，可能需要保持应用的状态。这通常涉及在重新加载前保存状态，并在加载后恢复。



JVM 的常见参数配置知道哪些？
堆内存大小设置:
-Xms<size>: 设置JVM启动时的初始堆内存大小。例如，-Xms256m 设置初始堆大小为 256 MB。
-Xmx<size>: 设置JVM可以使用的最大堆内存大小。例如，-Xmx1024m 设置最大堆大小为 1024 MB。
栈大小设置:
-Xss<size>: 设置每个线程的堆栈大小。例如，-Xss1m 设置线程堆栈大小为 1 MB。
年轻代与老年代大小设置:
-Xmn<size>: 设置年轻代的大小。
-XX:NewRatio=<ratio>: 设置年轻代（包括Eden和两个Survivor区）与老年代的比例。
垃圾收集器设置:
-XX:+UseG1GC: 使用G1垃圾收集器。
-XX:+UseParallelGC: 使用并行垃圾收集器。
-XX:+UseConcMarkSweepGC: 使用CMS垃圾收集器。
-XX:+UseSerialGC: 使用串行垃圾收集器。
GC日志设置:
-Xloggc:<file-path>: 将GC日志记录到文件。
-XX:+PrintGCDetails: 输出更详细的GC日志信息。
-XX:+PrintGCDateStamps: 在GC日志中添加时间戳。
堆转储设置:
-XX:+HeapDumpOnOutOfMemoryError: 在发生内存溢出时自动进行堆转储。
-XX:HeapDumpPath=<file-path>: 指定堆转储的文件路径。
性能优化相关:
-XX:CompileThreshold=<count>: 设置方法调用次数阈值，超过这个阈值就会被JIT编译器编译成本地代码。
-XX:SurvivorRatio=<ratio>: 设置Eden区与一个Survivor区的大小比例。
-XX:MaxTenuringThreshold=<threshold>: 设置对象在年轻代中的最大晋升年龄。
类加载相关:
-XX:+TraceClassLoading: 跟踪类的加载信息。
-XX:+TraceClassUnloading: 跟踪类的卸载信息。

JVM中的垃圾收集器有哪些，它们的工作原理是什么？
JVM中的垃圾收集器主要包括以下几种：

1、 Serial收集器：它是一个单线程收集器，工作时会暂停所有其他工作线程（"Stop-The-World"），它的优点是简单高效（与其他收集器的单线程比），适用于单核处理器的环境。

2、 ParNew收集器：可以看作是Serial收集器的多线程版本，主要用于新生代的垃圾收集，适合多核处理器环境。

3、 Parallel Scavenge收集器：也是一个新生代垃圾收集器，使用多线程收集，注重吞吐量（CPU用于运行用户代码的时间比率）。

4、 Serial Old收集器：是Serial收集器的老年代版本，单线程，采用标记-整理算法。

5、 Parallel Old收集器：是Parallel Scavenge收集器的老年代版本，使用多线程并行收集，目标是提高系统吞吐量。

6、 CMS（Concurrent Mark Sweep）收集器：以获取最短回收停顿时间为目标，使用多线程并发标记和清除算法。

7、 G1（Garbage-First）收集器：采用分区堆（Heap）和增量式垃圾回收，目标是兼顾吞吐量和停顿时间。


JVM中的类加载器有哪些，它们各自的作用是什么？
JVM中的类加载器主要有三种：

1、启动类加载器（Bootstrap ClassLoader） ：它负责加载存放在<JAVA_HOME>/jre/lib目录中，或者被-Xbootclasspath参数指定的路径中的类库。

2、扩展类加载器（Extension ClassLoader） ：它负责加载<JAVA_HOME>/jre/lib/ext目录中的类库。

3、应用程序类加载器（Application ClassLoader） ：它负责加载用户类路径（Classpath）上所指定的类库。

每个类加载器都有其特定的加载范围，这种层次关系保证了Java程序稳定运行。


JVM的永久代（PermGen）和元空间（Metaspace）有什么区别？
永久代（PermGen）和元空间（Metaspace）是JVM中存储类元数据的区域，二者的主要区别如下：

1、存储位置：永久代是在JVM的堆内存中，而元空间位于本地内存。

2、大小限制：永久代的大小是固定的，容易出现内存溢出；元空间利用本地内存，所以默认情况下只受本地内存大小限制。

3、回收机制：永久代的回收主要针对常量池的回收和对类型的卸载；元空间提供了更好的性能，在使用本地内存的同时，减少了垃圾收集的频率。

JVM中的堆和栈有什么区别？
堆和栈是JVM中两个重要的内存区域，它们的主要区别如下：

1、用途：堆用于存储对象实例和数组，是垃圾回收的主要区域；栈用于存储局部变量、操作数栈和控制流。

2、线程共享性：堆是被所有线程共享的内存区域，而栈是线程私有的。

3、内存分配：堆的内存分配是动态的，适用于动态对象的存储；栈的内存分配是连续的，适用于临时变量的存储。

4、内存回收：堆的内存回收由垃圾回收器处理，栈的内存分配和回收是自动的。

JVM中Full GC触发的原因有哪些？
Full GC触发的原因主要有以下几点：

1、老年代空间不足：老年代存放长期存活的对象，当老年代空间不足时，会触发Full GC。

2、永久代或元空间不足：当存储类元数据的区域空间不足时，同样会触发Full GC。

3、System.gc()调用：系统调用System.gc()时，通常会触发Full GC。

4、JVM参数：由于某些JVM参数设置不当，如过小的堆空间，也可能触发Full GC。

5、Eden区、Survivor区向老年代晋升失败：如果Eden区或Survivor区中的对象在Minor GC后仍然存活，并且老年代无法容纳这些对象，也会触发Full GC。

JVM中的类加载器有哪些，它们各自的作用是什么？
JVM中的类加载器主要有以下几种：

1、启动类加载器（Bootstrap ClassLoader）： 加载Java的核心库（JAVA_HOME/jre/lib/rt.jar等），是所有类加载器的父加载器。

2、扩展类加载器（Extension ClassLoader）： 加载JAVA_HOME/jre/lib/ext目录中或者由java.ext.dirs系统属性指定的路径中的类库。

3、应用程序类加载器（Application ClassLoader）： 加载用户类路径（Classpath）上的类库，如果应用中没有定义自己的类加载器，这将是默认的类加载器。

每个类加载器都有自己的职责范围，确保Java应用能够加载类的灵活性和安全性。

JVM中的栈溢出（StackOverflowError）是如何产生的，如何避免？
栈溢出（StackOverflowError）通常发生在以下情况：

1、深度递归调用： 方法反复递归调用自身，导致栈帧过多。

2、大量局部变量： 方法中定义了大量局部变量，占用过多栈空间。

避免栈溢出的方法：

1、优化递归逻辑： 转换为循环，减少递归深度。

2、增加栈大小： 通过-Xss调整线程栈的大小。

3、代码优化： 减少方法调用深度和局部变量的使用。

JVM中的内存分配与回收策略。
JVM中的内存分配与回收策略包括：

1、对象优先在Eden分配： 大部分情况下，对象首先在年轻代的Eden区分配。

2、大对象直接进入老年代： 较大的对象可能直接在老年代分配，避免在Eden区和Survivor区之间来回复制。

3、长期存活的对象进入老年代： 对象在年轻代经过多次GC后仍然存活，会被移动到老年代。

4、动态对象年龄判定： 为了更有效地进行垃圾收集，虚拟机会动态调整对象晋升老年代的年龄阈值。

5、分代收集算法： 年轻代使用复制算法，老年代使用标记-清除或标记-整理算法。


JVM中的直接内存（Direct Memory）是什么？
直接内存（Direct Memory）不是JVM堆内存的一部分，它是通过在Java代码中使用NIO库分配的内存，直接在操作系统的物理内存中分配。主要特点和用途：

1、避免内存复制： 直接内存访问避免了JVM堆和本地堆之间的内存复制，提高性能。

2、高效IO操作： 在NIO中，使用直接内存可以提高文件的读写效率。

3、内存管理： 直接内存的分配和回收不受JVM垃圾回收器管理，需要手动释放。

JVM的即时编译器（JIT）与解释器的工作机制有何不同？
JVM中的即时编译器（JIT）和解释器的主要区别在于：

1、解释器： 逐条将字节码解释执行，速度较慢，但几乎没有延迟。

2、即时编译器（JIT）： 将字节码编译成本地机器码，提高执行效率，但有编译耗时。

3、选择机制： JVM会根据代码的执行频率选择使用解释器还是JIT编译器，热点代码（频繁执行的代码）通常会被JIT编译。

JVM中的安全点（Safepoint）和安全区域（Safe Region）。
JVM中的安全点（Safepoint）和安全区域（Safe Region）是垃圾收集过程中的概念：

1、安全点（Safepoint）： 在这些点上，线程暂停执行，使得JVM可以安全地进行垃圾收集。

2、选择标准： 安全点的选择依据是“长时间执行”的指令，如方法调用、循环跳转等。

3、安全区域（Safe Region）： 当线程执行到无法达到安全点时，会标记自己处于安全区域，如在执行长时间的阻塞操作时。


JVM中的方法区（Method Area）和运行时常量池。
JVM中的方法区和运行时常量池：

1、方法区（Method Area）： 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

2、运行时常量池： 方法区的一部分，用于存储编译期生成的各种字面量和符号引用。

3、Java 8变更： 在Java 8中，传统的永久代被元空间（Metaspace）所替代，方法区的概念仍然存在，但实现已经变化。


RPC怎么做无损升级？

微服务升级时，RPC里怎么避免调用方业务受损呢？


微服务发布的时候，RPC怎么做零呼损？
rpc client 维度零呼损的有效措施是：重试
rpc server 维度零呼损的有效措施是：优雅启停

优雅停止/优雅下线 整个关闭过程中依赖了两次 RPC 调用：
一次是服务提供方通知注册中心下线操作
一次是注册中心通知服务调用方下线节点操作。

两次通知都是异步的，只保证最终一致性，并不保证强一致性。
这个中间，有一定的时间周期，所以，如果要做到应用无损升级， 需要在发出通知之后，隔一段时间，再把服务实例正式关闭。

优雅停止/优雅下线的简单流程
1. 下线实例在注册中心进行注销，注销该实例元数据信息；
2. 注册中心节点元数据更新周期为15s，调用方在感知注册中心实例变更后，更新本地缓存服务地址，不再将流量路由到下线实例，期间保障业务无中断；
3. 下线实例等待30s（2个心跳周期）后，进行实际下线操作；优雅停止的总结：优雅停止是当微服务快要下线的时候，先从注册中心进行去注销，然后把接收到的RPC调用消息，处理完毕后，再彻底关闭。 通过优雅停机，可以有效地防止升级期间，发送到老节点的呼损。
需要注意发送下线通知，到正式下线之间的时间间隔。

确保RPC零呼损的维度
如果要确保RPC零呼损， 至少可以从以下两个维度进行规避：
维度一： rpc client 维度
维度一： rpc server 维度
rpc client 维度 的核心策略是重试
rpc server 维度 的核心策略是 优雅启停
两个维度都不可或缺，都需要实现。






堆: 其唯一的用途就是存放对象实例：所有的对象实例及数组都在堆上进行分配。包含：新生代(Eden区、S0、S1)、老年代。官方推荐配置为年轻代大小占整个堆的3/8。-XX:NewRatio=3/5表示新生代和老年代的比值， 而Eden:S0:S1=8:1:1
注意：jdk1.8 开始 静态变量和字符串常量池在堆中


虚拟机栈: 描述的是java方法执行的内存模型,每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储 局部变量、操作数栈、动态链接、方法出口等信息.生命周期与线程相同。栈里面存放着各种基本数据类型和对象的引用
局部变量：定义在方法中的变量
操作数栈：程序运行中，一块临时存放要做操作的数据的空间。进行运算的地方
动态链接：Java Class文件中有很多符号引用，一部分在类加载的时候转化为直接引用，另一部分在每一次运行期间转化为符号引用，这部分被称为动态链接
方法出口：当一个方法执行的时候，只有两种可以退出方法的方法。第一种是JVM碰到任意一个方法返回的字节码指令，被称为正常完成出口。另一种是在执行方法中抛出异常并且未对异常进行处理，被称为异常完成出口。方法退出的时候相当于把栈帧出栈

如果在栈帧中有一个变量，类型为引用类型，比如Object obj=new Object()，这时候就是典型的栈中元素指向堆中的对象


本地方法栈:
本地方法栈则为虚拟机使用到的Native方法服务(非java代码的接口,比如C++的方法：Runtime.getRuntime().exec()是执行shell脚本的命令)

程序计数器:
当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响


堆—线程分配缓冲区
堆里面有一块线程私有的区域–线程分配缓冲区（TLAB）
对象逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。
JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力

public User test1() {
  User user = new User();
  user.setId(1);
  user.setName("zhuge");
  //TODO 保存到数据库
  return user;
}

public void test2() {
  User user = new User();
  user.setId(1);
  user.setName("zhuge");
  //TODO 保存到数据库
}

很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定–会逃逸，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了，对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉–不会逃逸.
JVM对于这种情况可以通过开启逃逸分析参数(-XX:+DoEscapeAnalysis)来优化对象内存分配位置，使其通过标量替换优先分配在栈上(栈上分配)，JDK7之后默认开启逃逸分析，如果要关闭使用参数(-XX:-DoEscapeAnalysis)
逃逸分析的好处：
1.栈上分配对象—对象占用的内存随着栈帧出栈而销毁，减轻垃圾回收的压力
2.同步消除—一个变量不会逃逸出线程就无法呗其他线程访问，那么这变量的读写就不会有竞争，就可以消除它的同步措施
3.通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。开启标量替换参数(-XX:+EliminateAllocations)，JDK7之后默认开启




查看当前服务器用的垃圾回收器：java -XX:+PrintCommandLineFlags -version

1、垃圾回收算法：
1.1、标记-清除(Mark-Sweep)
标记：找出内存中需要回收的对象，并且把它们标记出来
清除：清除掉被标记需要回收的对象，释放出对应的内存空间
缺点： 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
(1)标记和清除两个过程都比较耗时，效率不高
(2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无 法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

1.2、复制(Copying)
将内存划分为两块相等的区域，每次只使用其中一块,当其中一块内存使用完了，就将还存活的对象复制到另外一块上面，然后把已经使用过的内存空间一次清除掉
缺点: 空间利用率降低。

1.3、 标记-整理(Mark-Compact)
标记过程仍然与"标记-清除"算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，让所有存活的对象都向一端移动，清理掉边界意外的内存。
Young区：复制算法(对象在被分配之后，可能生命周期比较短，Young区复制效率比较高)
Old区：标记清除或标记整理(Old区对象存活时间比较长，复制来复制去没必要，不如做个标记再清理)

复制：发生在新生代(优点：无内存碎片，效率高 缺点：需要两倍的空间)
标记清理：发生在老年代(优点：占用空间少 缺点：会产生内存碎片)
标记整理：发生在老年代(优点：占用空间少，无碎片 缺点：对象移动，会消耗资源)

2、垃圾回收器的种类:
1、Serial:串行(-XX:+UseSerialGC)>为单线程环境设计，且使用一个线程回收垃圾，会暂停所有的用户线程(Stop The World)，不适合服务器环境(例如：用户用餐，餐厅叫出去要叫一个清洁工打扫，打扫完再回来吃)
新生代采用复制算法，老年代采用标记-整理算法
2、Parallel:并行(-XX:+UseParallelGC)>多个并行垃圾收集线程工作，此时用户线程是暂停的(Stop The World)，适用于科学计算、大数据处理首台处理等若交互环境(例如：用户用餐，餐厅叫出去要叫多个清洁工打扫，打扫完再回来吃)
新生代采用复制算法，老年代采用标记-整理算法
3、CMS:(-XX:UseConcMarkSweepGC)>用户线程和垃圾收集线程同时执行(并不一定是并行，可能交替执行)，不需要停顿用户线程
，适用对响应时间有要求的场景(例如：用户用餐，餐厅叫出去要叫多个清洁工打扫，边吃边打扫)
采用的是"标记-清除算法",整个过程分为4步：
(1)初始标记: 暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快
(2)并发标记: 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程， 这个过程耗时较长但是不需要停顿用户线程， 可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变
(3)重新标记: 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录(主要是处理漏标问题)，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法(见下面详解)做重新标记
(4)并发清除 CMS concurrent sweep 开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理
(5)并发重置：重置本次GC过程中的标记数据
对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下：
-Xms3072M -Xmx3072M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8
这样设置可能会由于动态对象年龄判断原则导致频繁full gc。于是我们可以更新下JVM参数设置：
-Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:SurvivorRatio=8
4、G1:(garbage first)(-XX:UseG1GC)>G1垃圾回收器将堆内存分割成不通的区域然后并发的对其进行垃圾回收 java11默认GC回收>> 器是ZGC。属于标记-整理算法
使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合
（1） 初始标记（Initial Marking） 标记一下GC Roots能够关联的对象，并且修改TAMS的值，需要暂 停用户线程 （STW）
（2）并发标记（Concurrent Marking） 从GC Roots进行可达性分析，找出存活的对象，与用户线程并发 执行
（3）最终标记（Final Marking） 修正在并发标记阶段因为用户程序的并发执行导致变动的数据，需 暂停用户线程
（4）筛选回收（Live Data Counting and Evacuation） 对各个Region的回收价值和成本进行排序，根据 用户所期望的GC停顿时间制定回收计划

 

三色标记算法是把Gc roots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成以下三种颜色：
黑色：表示对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过。 黑色的对象代表已经扫描过， 它是安全存活 的，如果有其他对象引用指向了黑色对象， 无须重新扫描一遍。 黑色对象不可能直接（不经过灰色对象） 指向某个白色对象。
灰色：表示对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过。
白色： 表示对象尚未被垃圾收集器访问过。
显然在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象， 即代表不可达。


3、如何判断一个对象是否应该被回收？
判断一个对象是否可达，不可达对象就将被回收，所谓可达就是从GCROOT开始是否是可以找到该对象 GCROOT是什么？
1、虚拟机栈中引用的对象（本地变量表）
2、方法区中静态属性引用的对象
3、方法区中常量引用的对象
4、本地方法栈中引用的对象（Native Object）

java中的引用类型和回收策略：
强引用：不会被GC回收
软引用：JVM充足不回收，JVM不足会被回收
弱引用： 会被GC回收
虚引用： 任何时候都能被回收


4、设置垃圾回收器？
（1）串行 -XX：+UseSerialGC -XX：+UseSerialOldGC
（2）并行(吞吐量优先)： -XX：+UseParallelGC -XX：+UseParallelOldGC
（3）并发收集器(响应时间优先) -XX：+UseConcMarkSweepGC -XX：+UseG1GC
例如：java -server -Xms1024m -Xmx1024m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal -XX:+UseG1GC -jar springboot2019-SNAPSHOT.jar

5、GC的类型
1.对Eden内存空间进行清理，即垃圾收集(Garbage Collect)，这样的GC我们称之为Minor GC
2.Old区的GC我们称作为Major GC
3.新生代(Minor GC)+老年代(Major GC) Full GC

6、触发Full GC的条件
老年代采取的垃圾回收算法是标记整理算法 老年代触发垃圾回收的机制，一般就是两个；
①在Minor GC之前，一通检查发现很可能Minor GC之后要进入老年代的对象太多了，老年代放不下， 此时需要提前触发Full
GC再然后再带着进行Minor GC；
②在Minor GC之后，发现剩余对象太多放入老年代都放不下了
在垃圾回收的过程中，尤其是Full GC。JVM会启动STW机制停止一切的用户进程。当然不同的垃圾收集器，STW的时间也不一样。
STW的作用： 在垃圾回收过程中，如果垃圾回收线程和用户线程一起工作。那么会造成一些对象的状态难以确定，标记起来也比较复杂，所以索性就使用STW机制停止一切用户线程。
当垃圾回收结束之后再恢复用户线程。用户可能在这一段时间内出现卡顿的现象，这就是STW

7、垃圾进入老年代的触发条件
1、当对象的年龄达到15岁时
默认的设置下，也就是躲过15次GC的时候，他就会转移到老年代里去 具体是多少岁进入老年代，可以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁
2、动态对象年龄判断
假如说当前放对象的Survivor区域里，一批对象的总大小大于了这块Survivor区域的内存大小的50%，
那么此时大于等于这批对象年龄的最大值对象，就可以直接进入老年代了
例如：年龄1+年龄2+年龄n，的多个年龄对象总和超过了Survivor区的50%，此时就会把年龄n以上的对象都放入老年代
3.大对象直接进入老年代
如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年代里去，压根不会经过年轻代,有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把它的值设置为字节数，比如“1048576”字节，就是1MB
4.老年代空间分配担保机制
年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)就会看一个“-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)的参数是否设置了如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。
如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，
如果回收完还是没有足够空间存放新的对象就会发生"OOM"
当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full
gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”
老年代大概率存放：
1.静态变量 – 生命周期是全局的
2.缓存对象
3.spring容器生成的对象
4.对象池中的对象


8、 JVM内存担保机制
在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

① 如果大于，则此次Minor GC是安全的
②如果小于，则虚拟机会查看-X:HandlePromotionFailure设置值是否允许担保失败。
如果HandlePromotionFailure=true,那么会继续检查 老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。
2.1> 如果大于，则尝试进行一次Minor GC,但这次Minor GC依然是有风险的：
2.2> 如果小于，则改为进行一次Full GC。 —— 如果HandlePromotionFailure=false,则改为进行一次Full GC。
担保机制，是为了减少Full GC的执行频次，提高了应用的性能。jdk8默认就设置了次参数


9、什么是强引用、软引用、弱引用、虚引用？
强引用:>只要还有强引用指向对象，就算OOM也不会回收该对象。Object o1=new Object(),就算强引用
软引用：>内存足够的情况不回收，内存不足时就回收的对象。SoftReference,用于内存敏感的地方
Object o1=new Object();
SoftReference sf = new SoftReference<>(o1);
弱引用:>不管内存是否够用，GC时一律回收 Object o1=new Object(); WeakReference sf = new WeakReference<>(o1);
虚引用:>PhantomReference 虚引用并不会决定生命周期，如果一个对象仅持有虚引用，那么他就和没有引用是一样的，任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列联合使用
主要作用是:跟踪对象被垃圾回收的状态




jvm参数
1.参数类型
①标配参数

例如：java -version/java -help /java -showversion

②x参数

java -Xint解释执行（java -Xint -version）、java -Xcomp第一次使用就编译成本地代码、java -Xmixed混合模式

③XX参数

-XX:+或者-某个属性值，其中+表示开启、-表示关闭 例如：jinfo -flag PrintGCDetails 进程号 ===>>>如果出现-XX:-PrintGCDetails 代表关闭了GC回收参数配置，如果是-XX:+PrintGCDetails 带表已配置了GC回收参数

④其他参数(所以这块也相当于是-XX类型的参数)

-Xms1000等价于-XX:InitialHeapSize=1000
-Xmx1000等价于-XX:MaxHeapSize=1000
-Xss100等价于-XX:ThreadStackSize=100

例如一个设置内存的示例: java -server -Xms1024m -Xmx1024m -XX:+UseG1GC -jar springboot2019-SNAPSHOT.war

总结公式：java -server jvm的各种配置参数 -jar jar包或者war包的名字

2.查看服务器启动了那些(查看jvm初始值 或者当前值的办法)
单位换算
1Byte(字节)=8bit(位)
1KB=1024Byte(字节)
1MB=1024KB
1GB=1024MB
1TB=1024GB




3.设置jvm调优的两种方法
设置jvm调优的两种方法:
①在tomcat的bin下面的catalina.sh 里，位置cygwin=false前 JAVA_OPTS=‘-server -Xms512m -Xmx768m -XX:NewSize=128m -XX:MaxNewSize=192m -XX:SurvivorRatio=8’
②使用jar包启动的话 java -server -Xms1024m -Xmx1024m -XX:+UseG1GC -jar springboot2019-SNAPSHOT.jar
war包也可以这样：java -server -Xms1024m -Xmx1024m -XX:+UseG1GC -jar springboot2019-SNAPSHOT.war
参数解释：
-Xms 初始堆内存大小
-Xmx 最大堆内存大小
-Xss 单个线程栈大小
-XX:NewSize 初始新生代堆大小
-XX:MaxNewSize 生代最大堆大小
-XX:MetaspaceSize 元数据区初始值(JDK1.8)
-XX:MaxMetaspaceSize 元数据区最大值(JDK1.8)
-XX:SurvivorRatio 用来设置新生代中eden空间和from/to空间的比例.
含以-XX:SurvivorRatio=eden/from=den/to
总结:在实际工作中，我们可以直接将初始的堆大小与最大堆大小相等， 这样的好处是可以减少程序运行时垃圾回收次数，从而提高效率。
例如：linux设置tomcat的catalina.sh
JAVA_OPTS=-Xms1024m -Xmx1024m -Xss1m -XX:MetaspaceSize=128m -XX:MAXMetaspaceSize=256m -XX:NewSize=256m -XX:MaxNewSize=256m
或者：java -server -Xms1024m -Xmx1024m -Xss1m -XX:MetaspaceSize=128m -XX:MAXMetaspaceSize=256m -XX:NewSize=256m -XX:MaxNewSize=256m -jar springboot2019-SNAPSHOT.jar

调整完查看,打印JVM所有参数列表的方法: java -XX:+PrintFlagsFinal -version
查看JVM初始化参数：java -XX:+PrintFlagsInitial

①执行 jps：(Java Virtual Machine Process Status Tool)是java提供的一个显示当前所有java进程pid的命令，适合在linux/unix平台上简单察看当前java进程的一些简单情况
②查看当前进程有哪些参数： 打印命令行参数 jinfo -flags 进程号。 ==>>例如打印GC信息：jinfo -flags
例如，打印指定进程全部参数： jinfo -flags 14857
例如，打印指定进程指定参数内容： jinfo -flag PrintGCDetails 14857

4.常用jvm调参语法:
1、jinfo 实时查看和调整JVM配置参数
查看
格式：
jinfo -flag name PID 查看某个java进程的name属性的值
jinfo -flags PID 查看某个java进程的全部属性的值

jinfo -flag MaxHeapSize PID
jinfo -flag UseG1GC PID
例如：
jinfo -flags 13573 *重点*
jinfo -flag MaxHeapSize 13573
jinfo -flag UseG1GC 13573

2、jstat 查看虚拟机性能统计信息
jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)

jstat命令可以查看堆内存各部分的使用量，以及加载类的数量
jstat [-命令选项] [vmid] [间隔时间/毫秒] [查询次数]
格式：
jstat -class PID 1000 10 查看某个java进程的类装载信息，每1000毫秒输出一次，共输出10次
例如：
查看类装载信息: jstat -class 9939
垃圾回收统计：jstat -gc 9939

3、Jstack 查看线程堆栈信息
格式：jstack PID

Jstack 用jstack加进程id查找死锁(查找递归，死循环等得位置) 行
jstack >19663|grep 4cd0 -A60
//19663是进程号，4cd0是十六进制的线程号，-A60是打印错误附近的60行代码

4. jmap 生成堆转储快照
打印出堆内存相关信息： jmap -heap PID
例如：jmap -heap 2304

jmap 用来查看内存信息，实例个数以及占用内存大小 jmap ‐histo 14660
#查看历史生成的实例，14660是进程id用jps查 jmap ‐histo:live 14660 #查看当前存活的实例，，14660是进程id用jps查。执行过程中可能会触发一次full gc 堆信息：jmap -heap 14660 也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)

-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./ （路径）
例如：
‐Xms10M ‐Xmx10M ‐XX:+PrintGCDetail‐XX:+HeapDumpOnOutOfMemoryError ‐XX:HeapDumpPath=D:\jvm.dump
jmap命令查看堆内存 jmap -heap 进程ID
查看内存使用情况 jmap -heap 9939 jmap ‐histo <pid> | more
例如： 查看内存中对象数量及大小
jmap -histo:live 11927 | more
自动导出内存溢出文件

也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)
-XX:+HeapDumpOnOutOfMemoryErro -XX:HeapDumpPath=./ （路径）
这样在内存溢出的时候就会自动导出一个dump文件到 路径 指定的位置
在jdk里面有个jvisualvm.exe，导入此dump文件就可以看到GC、内存溢出详情

5、调优实例
①错误：java.lang.OutOfMemoryError:Metaspace
元空间大小内存溢出？
设置元空间大小方法：-XX:MetaspaceSize=1024m* 就是设置元空间的大小
实战中设置元空间大小：
java -server -Xms1024m -Xmx1024m -XX:MetaspaceSize=1024m -XX:+PrintFlagsFinal -jar springboot2019-SNAPSHOT.jar
元空间的本质和永久代类似，都是对JVM规范中的方法区的实现。不过元空间与永久代的最大区别是:元空间并不在虚拟机中，而是使用本地内存，默认情况下元空间仅受本地内存大小限制
查看jvm所有配置信息：java -XX:+PrintFlagsFinal -version
这样找到MetaspaceSize对应的大小是21807104 字节 换算过来才 20.79m。也就是说元空间虽然只跟本地内存有关，但它初始值只有21m，可以调大
②栈空间的大小调整？
-Xss等价于：-XX:ThreadStackSize

java -XX:+PrintFlagsFinal -version查找ThreadStackSize是栈空间大小，会发现初始值为0
栈空间默认值跟平台有关：
Linux(x64):1024kb
OS X(64-bit):1024kb
Windows:虚拟内存的默认值
例如：java -server -Xss128k -jar springboot2019-SNAPSHOT.jar
③查看垃圾回收多少次后才会由新生代进入老年代？
3.1、查看程序进程 jps -l
3.2、查看默认垃圾回收次数，才进入老年代 jinfo -flag
MaxTenuringThreshold 进程号 会看到默认是15次(最大设置为15)

四、调优示例
问题一 CPU占用高调优

方法 1、 cpu占用过高，定位java代码中的办法？
1、使用 top查看占用cpu高的程序
例如：top
假如，cpu占用最高的就是 elasticsearch （一般是业务jar包）
37 root 20 0 0 0 0 S 0.3 0.0 0:01.82 elasticsearch
2、使用jps或ps -ef|grep “elasticsearch” 去找出这个占用高的程序的进程号
例如:jps -l
1541 Elasticsearch
3、定位到具体的线程或代码： ps -mp 进程 -o THREAD,tid,time
-m：显示所有线程
-p： pid进程使用cpu时间
-o:该参数后是用户自定义格式
例如:ps -mp 1541 -o THREAD,tid,time
输出很多(最后一列是时间，假如这个线程耗时最长)：esuser 0.0 19 - futex_ - - 1541 00:00:08
找到时间最长的那个线程号
4、把需要的线程id转换为16进制的格式(要英文小写的)
方法一：执行命令：printf “%x\n” 有问题的线程id。例如： printf "%x\n" 2242
输出：8c2
方法二：用计算器转换为16进制
5、执行命令：jstack 进程ID |grep tid(16进制的线程id英文小写) -A60
例如：jstack 2242 |grep 8c2 -A60
tid(16进制的线程id英文小写)：是一个整体是指上面换算后的线程id（要16进制那个值）
-A60是指打印最近的60行
在打印信息中找到包名就是java代码对应的哪一行报出来的错！

方法 2 jstack找出占用cpu最高的线程堆栈信息
使用命令top 找到占用CPU比例最高的进程
使用命令top -p ，显示你的java进程的内存情况，pid是你的java进程号，比如19663 top -p 19663 3，按H，获取每个线程的内存情况
找到内存和cpu占用最高的线程tid，比如19664
转为十六进制得到 0x4cd0，此为线程id的十六进制表示
执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调 用方法
查看对应的堆栈信息找出可能存在问题的代码


3.线程安全是什么？产生原因以及解决办法？
1.定义 线程安全是指在多线程环境下，一个类或对象在多个线程同时访问时，能够保持其状态的一致性和正确性
2、出现线程安全问题的原因
操作系统对线程的调度是随机的/抢占式（主要原因）
多个线程修改同一个变量
修改操作不是原子的
内存可见性问题
指令重排序问题
3、如何解决线程安全？
针对线程的抢占式执行，可以采用wait，notify来调配线程执行顺序。

对于多个线程修改同一个变量，可以调节代码结构，做到一定程度上的规避(比如说给第二个线程创建一个新的对象来规避)。

操作不是原子性，可以利用synchronized进行加锁操作，使操作变为原子性。 synchronized可以修饰代码块、方法、修饰静态方法（锁类对象）。锁具有互斥性，当一个线程对其加锁后，其他线程就不能够在对其进行修改或访问，需要等该线程释放锁后才能重新访问

内存可见性问题，是编译器优化引入的bug，当一个线程在修改一个内存数据时，另一个线程无法及时感知到，就会导致代码出现错误。使用volatile关键字修饰可能出现内存可见性问题的变量，就可以避免编译器只读寄存器不读内存的情况，解决了内存可见性问题

指令重排序也是编译器优化导致的bug，这里就不过多讲解了


2、类的加载机制过程
1.装载(Load)
查找和导入class文件
(1)通过一个类的全限定名获取定义此类的二进制字节流
(2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
(3)在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口
2.链接(Link)
2.1 验证(Verify)
保证被加载类的正确性
文件格式验证
元数据验证
字节码验证
符号引用验证
2.2 准备(Prepare)
为类的静态变量分配内存，并将其初始化为默认值
2.3 解析(Resolve)
把类中的符号引用转换为直接引用
符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。在Class文件中就是这种
直接引用：直接引用可以是 1、直接指向目标的指针 2、相对偏移量 3、一个能间接定位到目标的句柄
3 初始化(Initialize)
对类的静态变量，静态代码块执行初始化操作
4 使用
5 卸载


解释堆和栈的区别?

答：堆（Heap）是Java中对象实例存储的地方，所有线程共享堆空间。栈（Stack）是线程私有的，用于存储局部变量和方法调用的执行上下文。堆是垃圾收集器管理的主要区域，而栈内存由JVM自动管理。

什么是类加载器（ClassLoader）和它的双亲委派模型？

答：类加载器负责动态加载Java类文件到JVM。双亲委派模型是一种类加载机制，其中每个类加载器在尝试加载类之前，会先委托给它的父加载器去尝试加载这个类。这种模型确保了类的唯一性和避免重复加载。

解释JVM中的同步块和同步方法的区别?

答：同步块（synchronized block）是在代码的特定部分进行同步，只有进入该块的代码才会被同步。同步方法（synchronized method）则是对整个方法进行同步，确保方法在执行期间不会被其他线程中断。




解释JVM中的线程栈大小对性能的影响?

答：线程栈大小决定了每个线程可以创建的局部变量的数量。如果栈大小设置得过小，可能会导致栈溢出错误。如果设置得过大，可能会浪费内存资源。合理的栈大小可以提高性能，避免不必要的线程创建和上下文切换。


解释JVM中的类数据共享（Class Data Sharing, CDS）特性?

答案：CDS是JDK 11中引入的一个特性，它允许多个JVM进程共享类元数据，从而减少内存占用和类加载时间。这对于大型应用程序和微服务架构尤其有用。



什么是JVM的ZGC和Shenandoah垃圾收集器？

答：ZGC和Shenandoah是JDahdi的实验性垃圾收集器，它们旨在提供低延迟的垃圾收集。ZGC专注于减少GC停顿时间，而Shenandoah则尝试在并发标记阶段减少GC的停顿。


解释JVM中的代码缓存（Code Cache）及其优化?

答：代码缓存是JVM用于存储JIT编译后的本地代码的内存区域。优化代码缓存包括合理设置缓存大小、使用分层编译（Tiered Compilation）等，以提高编译代码的效率和程序的执行速度。





32.什么是Survivor区，以及它在垃圾收集中的作用是什么？

答：Survivor区是强代中的两个（或更多）小的内存区域，用于存放在垃圾收集期间幸存下来的对象。对象在被提升到老年代之前，会在Survivor区之间来回移动，这个过程称为“幸存者”模型。

33.解释JVM中的Eden区及其作用？

答：Eden区是年轻代中的主要区域，新创建的对象首先被分配在这里。Eden区通常比两个Survivor区的总和要大，因为它是大多数对象的初始存放地。

35.解释JVM中的内存溢出（OutOfMemoryError）和它的原因？

答：内存溢出是指JVM在运行时尝试分配内存，但无法找到足够的连续空间来满足请求时发生的错误。这通常是由于内存泄漏、不合理的内存分配或物理内存不足引起的。

什么是JVM的编译器优化，举例说明?

答：JVM的编译器优化是指JIT编译器在运行时对热点代码（频繁执行的代码）进行的优化，以提高执行效率。例如，JVM可能会将解释执行的字节码转换为本地机器码，或者应用内联缓存来避免重复的方法调用开销。


解释JVM中的锁粗化（Lock Coarsening）和锁消除（Lock Elimination）优化?

答：锁粗化是将多个连续的同步块合并为一个同步块的优化，以减少锁的获取和释放开销。锁消除是当JVM确定一个变量在方法执行期间不会被其他线程访问时，移除对这个变量的

什么是JVM的线程局部变量（Thread-Local Variable）？

答：线程局部变量是每个线程各自拥有的变量，它们在线程之间互不影响，通常用于防止共享资源的线程安全问题。


什么是JVM的垃圾收集器的增量收集（Incremental Collection）？

答：增量收集是指将GC的工作分批进行，每次只处理一部分内存区域，以减少单次GC的停顿时间。