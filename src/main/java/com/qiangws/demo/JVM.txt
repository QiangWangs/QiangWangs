https://www.cnblogs.com/crazymakercircle/p/14365820.html#autoid-h3-2-0-0

java8及以后的版本使用Metaspace(元空间)来代替永久代，，Metaspace是方法区在HotSpot中的实现，它与持久代最大区别在于，Metaspace并不在虚拟机内存中而是使用本地内存也就是在JDK8中,
classe metadata(the virtual machines internal presentation of Java class),被存储在叫做Metaspace的native memory

永久代: 虚拟机加载的类信息 + 常量池 + 静态变量 + 即时编译器编译后的代码等数据;
元空间: 类信息 + 常量池 + 静态变量 + 即时编译器编译后的代码等数据;
元空间和永久代最大的区别在于：永久代使用的是JVM的堆内存，元空间使用的是物理内存，也就是说，只要物理内存足够，元空间就不会OOM。

元空间会OOM么？在什么情况下会产生内存溢出？
元空间不会OOM，元空间是物理内存，只要物理内存足够，元空间就不会OOM。

元空间会产生内存溢出么？在什么情况下会产生内存溢出？
出现错误的主要原因, 是加载到内存中的 class 数量太多或者体积太大。
解决办法: 增加 Metaspace 的大小   -XX:MaxMetaspaceSize=512m
查看元空间大小: java -XX:+PrintFlagsInitial

元空间与永久代最大区别在于:Metaspace并不在虚拟机内存中而是使用本地内存也就是在JDK8中

Java内存区域
说一下 Java 堆空间及 GC？
堆空间是 JVM 管理的内存中最大的一块，堆是进程中各个线程共享的内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配。堆空间可以细分为: 新生代(Eden + S0 + S1) + 老年代 + 永久代(方法区)
当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。

说一下 JVM 的主要组成部分及其作用？
JVM 是可运行 Java 代码的虚拟计算机系统。它包括一个指令集解释器，一个运行时数据区域，以及一组库。JVM 是 Java 平台的一部分，负责运行 Java 应用程序。
JVM 的主要组成部分有：
JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。
Class loader(类装载)：根据给定的全限定名类名(如：java.lang.Object)来装载class文件到
Runtime data area中的method area。
Execution engine（执行引擎）：执行classes中的指令。
Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。
Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。

类加载器：负责加载 .class 文件，即把类的字节码载入内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构。
执行引擎：执行引擎负责执行字节码，解释器负责解释执行字节码，即时编译器编译执行字节码，编译器以方法为单位，将字节码编译成机器码。
本地库接口：本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序，Java 诞生的时候是 C/C++横行的时候，要想立足，必须有调用 C/C++程序，于是就在内存中专门开辟了一块区域处理 C/C++程序，即本地方法栈，由于它需要与底层交互，于是称其为 Native Interface。
运行时数据区：运行时数据区是 JVM 所管理的内存，也是 Java 程序运行的真正环境，它主要包括以下部分：
方法区（Method Area）：方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
堆（Heap）：堆是各个线程共享的内存区域，它在虚拟机启动时创建。堆是 Java 对象的存储区域，所有的对象实例以及数组都要在堆上分配。堆被划分为新生代和老年代。新生代又被划分为 Eden 空间、From Survivor 空间和 To Survivor 空间。
栈（Stack）：栈是每个线程私有的内存区域，它用于存储局部变量、操作数栈、动态链接、方法出口等信息。栈分为虚拟机栈和本地方法栈，虚拟机栈用于执行 Java 方法，本地方法栈用于执行 Native 方法。
程序计数器（Program Counter Register）：程序计数器是每个线程私有的内存区域，它用于存储当前线程所执行的字节码的行号指示器。


JVM内存包括哪些？
堆内存（Heap）: 存放对象实例和数组，是线程共享的，堆内存是 JVM 管理的内存中最大的一块，堆是进程中各个线程共享的内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配。堆空间可以细分为:
 新生代(Eden + S0 + S1) + 老年代 + 永久代(方法区)。
方法区（Method Area）: 存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是线程共享的。
栈内存（Stack）: 存放局部变量表、操作数栈、动态链接、方法出口等信息，是线程私有的。
程序计数器（Program Counter Register）: 每个线程都有一个程序计数器，用于记录当前线程正在执行的虚拟机字节码指令的地址。
本地方法栈（Native Method Stack）: 用于执行本地方法（Native Method），是线程私有的。

JVM总内存= 栈 + 堆 +Native
Native= 堆外内存（直接内存） + 元空间
非堆 = 元空间

本地方法栈和虚拟机栈的主要区别？
虚拟机栈执行的是java方法
本地方法栈执行的是native方法

什么是堆内存?
堆内存是 JVM 管理的内存中最大的一块，堆是进程中各个线程共享的内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配。
堆空间可以细分为: 新生代(Eden + S0 + S1  (1 伊甸园区 + 2 幸存者区 , 一般称为年轻代。)) + 老年代 + 永久代(方法区, 1.8后永久代被元空间取代了)。

在jvm参数中只要使用-Xms，-Xmx等参数就可以设置堆的大小和最大值;
堆内内存 = 新生代+老年代

常见的垃圾回收算法主要有？
引用计数器法（Reference Counting）
标记清除法（Mark-Sweep）
复制算法（Coping）
标记压缩法（Mark-Compact）
分代算法（Generational Collecting）
分区算法（Region）

JVM内存连环炮：什么是非堆内存?
除堆内存之外，JVM的内存池还包括非堆（NON_HEAP），
非堆内存 大概包括：
MetaSpace   元空空间
CodeCache   代码缓存
Compressed Class Space    压缩类空间

什么是堆外内存/直接内存（direct memory）？
堆外内存, 常常又叫做直接内存。 和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

介绍一下方法区和永久代的区别
方法区是 JVM 规范中定义的一块区域，用于存储类信息、常量池、静态变量等数据，而永久代是 HotSpot 虚拟机对方法区的一种实现方式。
在 JDK 1.8 之前，HotSpot 虚拟机使用永久代来实现方法区，而在 JDK 1.8 之后，永久代被元空间（Metaspace）所取代。


为什么用元空间替换永久代？
为永久代设置最大空间大小是难以确定的。对永久代进行调优是很困难的。
元空间使用的是物理内存，也就是说，只要物理内存足够，元空间就不会OOM。元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的最大大小仅受本地内存限制。

为什么调整字符串常量池的位置？
字符串常量池在JDK1.7之前是放在了永久代中的，而在JDK1.7之后，字符串常量池被移到了堆内存中。这是因为永久代的空间有限，而字符串常量池中的字符串数量可能会非常大，如果字符串常量池放在永久代中，可能会导致永久代内存不足，
从而引发OutOfMemoryError。将字符串常量池移到堆内存中，可以避免这个问题，同时也可以更好地管理字符串常量池中的字符串。

JDK7中将字符串常量池放到了堆空间中：因为永久代的回收效率很低，在Full GC时才会触发，而Full GC在老年代的空间不足、永久代不足时才会触发，这就导致字符串常量池回收效率不高；
而我们开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。将字符串常量池放到堆里，能及时回收内存。



什么是执行引擎？
执行引擎是 JVM 的核心组成部分之一，它负责执行 Java 字节码。执行引擎包括解释器和即时编译器两部分。解释器负责逐行解释执行 Java 字节码，而即时编译器则负责将 Java 字节码编译成本地机器码，以提高程序的执行效率。执行引擎是
JVM 的核心组成部分之一，它负责执行 Java 字节码。执行引擎包括解释器和即时编译器两部分。解释器负责逐行解释执行 Java 字节码，而即时编译器则负责将 Java 字节码编译成本地机器码，以提高程序的执行效率。

执行引擎是 java 虚拟机的最核心组件之一，它负责执行虚拟机的字节码，有即时编译和解释执行，通常采用解释执行方式。解释执行是指解释器通过每次解释并执行一小段代码来完成.class程序的所有操
作。即时编译则是将.class文件翻译成机器码在执行（比如：经常多次访问的代码可以全部编译）
垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对 栈 堆进行回收。其中， java 堆是垃圾收集器的工作重点。有三类：增量垃圾回收，分代复制垃圾回收，标记垃圾回收
和 C/C++不同， java 中所有的对象空间释放都是隐式的，也就是说， java 中没有类似 free()或者 delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。



成员变量、局部变量、类变量分别存储在内存的什么地方？
成员变量：成员变量存储在堆内存中，包括静态变量和实例变量。静态变量在类加载时分配内存，实例变量在对象创建时分配内存。
局部变量：局部变量存储在栈内存中，包括方法参数和方法的局部变量。局部变量在方法调用时分配内存，方法调用结束后，局部变量所占用的内存会被释放。
类变量：类变量存储在方法区中，包括静态变量和实例变量。静态变量在类加载时分配内存，实例变量在对象创建时分配内存。

类变量:
类变量是用static修饰符修饰，定义在方法外的变量，包括静态变量和实例变量。
随着java进程产生和销毁在java8之前把静态变量存放于方法区，在java8时存放在堆中
成员变量:
成员变量是定义在类中，但是没有static修饰符修饰的变量，随着类的实例产生和销毁，是类实例的一部分
由于是实例的一部分，在类初始化的时候，从运行时常量池取出直接引用或者值，与初始化的对象一起放入堆中
局部变量:
局部变量是定义在类的方法中的变量在所在方法被调用时放入虚拟机栈的栈帧中，方法执行结束后从虚拟机栈中弹出，所以存放在虚拟机栈中


类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？
类常量池、运行时常量池、字符串常量池是 Java 虚拟机中用于存储常量的三个不同区域。
类常量池与运行时常量池都存储在方法区，而字符串常量池在jdk7时就已经从方法区迁移到了java堆中。
在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和符号引用，而字面量的一部分便是文本字符，在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池；
对于文本字符来说，它们会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池；字符串常量池存储的是字符串对象的引用，而不是字符串本身。

类常量池（Class Constant Pool）：类常量池是每个类或接口的常量池，用于存储编译期生成的各种字面量和符号引用。类常量池在编译时被写入到类的字节码文件中，并在类加载时被加载到方法区中。
运行时常量池（Runtime Constant Pool）：运行时常量池是方法区的一部分，用于存储在类加载时生成的常量池的运行时表示形式。运行时常量池在类加载时被创建，并在程序运行期间可以被修改。
字符串常量池（String Constant Pool）：字符串常量池是方法区的一部分，用于存储字符串常量。字符串常量池在类加载时被创建，并在程序运行期间可以被修改。


使用堆外内存的优点
减少了垃圾回收 因为垃圾回收会暂停其他的工作。
加快了复制的速度 堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略 掉了这个工作。  这样就避免了在 Java堆和 Native 堆中来回复制数据

深拷贝和浅拷贝?
浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址，
深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。
浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。
深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。



说一下堆栈的区别？
堆和栈是 Java 虚拟机中两种不同的内存区域，它们各自有不同的用途和特点。
堆（Heap）：堆是 Java 虚拟机中用于存储对象实例的区域，所有的对象实例都在堆上分配内存。堆是线程共享的，多个线程可以同时访问堆中的对象。堆的大小可以动态调整，可以通过 JVM 参数来设置堆的大小和调整策略。
栈（Stack）：栈是 Java 虚拟机中用于存储方法调用和局部变量的区域。栈是线程私有的，每个线程都有自己独立的栈。栈的大小是固定的，一旦栈的大小超过了设定的值，就会发生栈溢出（StackOverflowError）。
堆和栈的区别主要有以下几个方面：
存储内容：堆用于存储对象实例，栈用于存储方法调用和局部变量。
共享性：堆是线程共享的，栈是线程私有的。
内存管理：堆的内存管理是由垃圾回收器自动进行的，栈的内存管理是由 JVM 自动进行的。


物理地址
堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩）
栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。
内存分别
堆因为是不连续的，所以分配的内存是在 运行期 确认的，因此大小不固定。一般堆大小远远大于栈。
栈是连续的，所以分配的内存大小要在 编译期 就确认，大小是固定的
存放的内容
堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行
1. 静态变量放在方法区
2. 静态的对象还是放在堆
程序的可见度
堆对于整个应用程序都是共享、可见的。
栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同

Java 中堆和栈有什么区别？
JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程

队列和栈是什么？有什么区别？
队列（Queue）和栈（Stack）是两种基本的数据结构
队列是一种先进先出（FIFO）的数据结构，它支持两种基本操作：入队（enqueue）和出队（dequeue）。入队操作将一个元素添加到队列的尾部，而出队操作则从队列的头部移除一个元素。队列通常用于实现缓冲区、任务队列等场景。
栈是一种后进先出 - 先进后出（LIFO）的数据结构，它支持两种基本操作：入栈（push）和出栈（pop）。入栈操作将一个元素添加到栈的顶部，而出栈操作则从栈的顶部移除一个元素。栈通常用于实现函数调用、表达式求值等场景。
队列和栈的区别主要体现在它们的操作方式和用途上。队列是一种先进先出的数据结构，它支持入队和出队两种操作，适用于实现缓冲区、任务队列等场景。而栈是一种后进先出的数据结构，它支持入栈和出栈两种操作，
适用于实现函数调用、表达式求值等场景。另外，队列通常用于实现多线程之间的数据共享，而栈通常用于实现单线程中的数据共享。

队列和栈都是被用来预存储数据的。
操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。
可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。
操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,
即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。


虚拟机栈(线程私有)
每个线程运行时所需要的内存，称为虚拟机栈。每个线程创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Frame）,对应着一次次的Java方法调用。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。
本地方法栈(线程私有)
与虚拟机栈所发挥的作用非常相似，区别是：虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。


什么是直接内存？
直接内存（Direct Memory）是Java虚拟机（JVM）中的一种内存区域，它不是Java堆的一部分，而是直接由操作系统管理的内存。直接内存通常用于处理I/O操作，例如读写文件、网络通信等。直接内存不受Java堆的大小限制，
因此可以比堆内存更快地处理大量数据。但是，直接内存的分配和释放需要手动进行，如果忘记释放，可能会导致内存泄漏。 

直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用:
在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避
免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。




























